if
if는 test라는 속성과 함께 특정한 조건이 true가 되었을때 포함된 SQL을 사용하고자 할 때 작성
제목 내용 작성자에 대해 검색해야 하는 상황이라고 가정
검색조건이 T이면 제목검색
검색조건이 C이면 내용검색
검색조건이 W이면 작성자검색

<if test="type == 'T'.toString()">
	(title like '%' || #{keyword} || '%')
</if>


<if test="type == 'C'.toString()">
	(content like '%' || #{keyword} || '%')
</if>
<if test="type == 'W'.toString()">
	(writer like '%' || #{keyword} || '%')
</if>

if안에 들어가는 표현식은 OGNL표현식이라는것을 이용합니다.

<choose>
if와 달리 choose는 여러 상황들 중 하나의 상황에서만 동작한다

<choose>
<when test="type == 'T'.toString()">
	(title like '%' ||#{keyword}||'%')
</when>
<when test="type == 'C'.toString()">
	(content like '%' ||#{keyword}||'%')
</when>
<when test="type == 'W'.toString()">
	(writer like '%' ||#{keyword}||'%')
</when>
<oherwise>
	(title like '%'||#{keyword}||'%' OR content like '%'||#{keyword}||'%')
</oherwise>
</choose>

trim, where, set 은 단독으로 사용되지 않고, if나 choose와 같은 태그들을 내포하여 SQL들을 연결해주고, 앞뒤에 필요한 구문들(AND, OR, WHERE)을 추가하거나 생
략하는 역할을 한다. 

URI(Uniform Resource Identifier) 자원의 식별자
URL은 '이 곳에 가면 당신이 원하는 것을 찾을 수 있습니다.'와 같은 상징적인 의미가 좀 더 강하다면, URI는 '당신이 원하는 곳의
주소는 여깁니다.와 같이 좀 더 현실적이고 구체적인 의미가 있다.

REST는 'Representational State Transfer'의 약어로 하나의 URI는 하나의 고유한 리소스를 대표하도록 설계된다는 개념에
전송방식을 결합해서 원하는 작업을 지정합니다. 
예를 들어 '/board/123'은 게시물 중에서 123번이라는 고유한 의미를 가지도록 설계하고, 이에 대한 처리는 GET, POST 방식과
같이 추가적인 정보를 통해서 결정한다. 
URI + GET/POST/PUT/DELETE/....

스프링은 @RequestMapping이나 @ResponseBody와 같이 REST 방식의 데이터 처리를 위한 여러종류의 어노테이션과 기능이
있다. Rest와 관련해서 알아 두어야 하는 어노테이션

@RestController - Controller가 REST 방식을 처리하기 위한 것임을 명시한다.
@ResponseBody - 일반적인 JSP와 같은 뷰로 전달되는 게 아니라 데이터 자체를 전달하기 위한 용도
@PathVariable - URL 경로에 있는 값을 파라미터로 추출하려고 할 때 사용
@CrossOrigin - Ajax의 크로스 도메인 문제를 해결해주는 어노테이션
@RequestBody - JSON 데이터를 원하는 타입으로 바인딩 처리

@RestController
-REST방식에서 가장 먼저 기억해야 하는 점은 서버에서 전손하는 것이 순수한 데이터라는 점.
기존의 Controller에서 Model에 데이터를 담아서 JSP 등과 같은 뷰로 전달하는 방식이 아니므로 기존의 Controller와 조금 다르다

스프링 4에서부터는 @Controller외에 @RestController라는 어노테이션을 추가해서 해당 Controller의 모든 메서드의 리턴
타입을 기존과 다르게 처리한다는 것을 명시한다.
@RestController 이전에는 @Contoller와 메서드 선언부에 @ResponseBody를 이용해서 동일한 결과를 만들 수 있다
@RestController는 메서드의 리턴 타입으로 사용자가 정의한 클래스 타입을 사용할 수 있고, 이를 JSON이나 XML로 자동 처리
할 수 있다.

JSON은 'JavaScript Object Notatiton'의 약어로 구조가 있는 데이터를 '{}'로 묶고 '키'와 '값'으로 구성하는 경량의 데이터 포맷.
프로그래밍 언어에서 말하는 객체들의 구조는 '{}'를 이용해서 다음과 같이 표현할 수 있다.
{
	"이름":"홍길동",
	"나이":25,
	"성별":"여",
	"주소":"서울특별시 양천구 목동",
	"특기":["농구","도술"],
	""가족관계": {"#":2, "아버지" : "홍판서", "어머니": "춘섬"},
}
구조를 표현한 문자열은 프로그래밍 언어에 관계 없이 사용할 수 있기 때문에 XML과 더불어 가장 많이 사용되는 데이터 형태

@RestController는 기존의 @Controller에서 사용하던 일반적인 타입이나 사용자가 정의한 타입(클래스)을 사용한다.
여기에 추가로 몇가지 어노테이션을 이용하는 경우가 있다.
-@PathVariable : 일반 컨트롤러에서도 사용이 가능하지만 REST 방식에서 자주 사용된다. URL 경로의 일부를 파라미터로 
사용할 때 이용
-@RequestBody : JSON 데이터를 원하는 타입의 객체로 변환해야 하는 경우 주로 사용

@PathVariable
REST방식에서는 URL 내에 최대한 많은 정보를 담으려고 노력한다. 예전에는 "?' 뒤에 추가되는 쿼리 스트링이라는 형태로
파라미터를 이용해서 전달되던 데이터들이 REST방식에서는 경로의 일부로 차용되는 경우가 많다

스프링 MVC에서는 @PathVariable 어노테이션을 이용해서 URL 상에 경로의 일부를 파라미터로 사용할 수 있다.

http://localhost:8089/sample/{sno}
http://localhost:8089/sample/{sno}/page/{pno}

위의 URL에서 '{}'로 처리된 부분은 컨트롤러의 메서드에서 변수로 처리가 가능하다
@PathVariable은 '{}'의 이름을 처리할 때 사용

REST 방식에서는 URL자체에 데이터를 식별할 수 있는 정보들을 표현하는 경우가 많으므로 다양한 방식으로 @PathVariable이
사용된다.


특정 댓글의 클릭 이벤트 처리
댓글은 댓글의 목록에서 내용이 모두 출력되기 때문에 별도로 클릭한다는 것은 해당 댓글을 수정하거나 삭제하는 경우에 발생
한다. 댓글의 수정과 삭제는 원칙적으로 로그인한 사용자가 해당 댓글의 작성자인 경우에만 허락되어야한다. 다만 현재까지 로
그인에 대해서는 처리된 적이 없으므로 코드에서는 어떠한 댓글도 수정/삭제가 되도록 작성

DOM에서 이벤트 리스너를 등록하는 것은 반드시 해당 DOM 요소가 존재해야만 가능하다. 위와 같이 동적으로 Ajax를 통해서
<li> 태그들이 만들어지면 이후에 이벤트를 등록해야 하기 때문에 일반적인 방식이 아니라 '이벤트 위임(delegation)'의 형태로
작성해야 한다.

'이벤트 위임'이 말은 거창하지만 실제로는 이벤트를 동적으로 생성되는 요소가 아닌 이미 존재하는 요소에 이벤트를 걸어주고,
나중에 이벤트의 대상을 변경해주는 방식이다. jQuery는 on()을 이용해서 쉽게 처리가 가능하다.

AOP(Aspect-Oriented Programming)는 '관점 지향 프로그래밍'이라는 의미로 번역되는데, 객체지향에서 특정 비즈니스 로직에
걸림돌이 되는 공통 로직을 제거할 수 있는 방법을 제공한다. AOP를 적용하면 기존의 코드에 첨삭 없이, 메서드의 호출 이전 혹은
이후에 필요한 로직을 수행하는 방법을 제공한다.

트랜잭션 작업은 데이터베이스를 이용할 때 '두개이상의 작업이 같이 영향을 받는 경우'에 필요하다.
과거에는 코드 내에 개발자가 직접 이를 지정하고 사용했다면 스프링에서는 XML이나 어노테이션만으로 트랜잭션이 처리된
결과를 만들어 낼 수 있다.

AOP는 흔히 '관점 지향 프로그래밍'이라는 용어로 번역되는데, 이 때 '관점'이라는 용어가 현실적으로 와닿지 않기 떄문에
어렵게 느껴질 수 있다. '관점'이라는 용어는 개발자들에게 '관심사'라는 말로 통용된다. '관심사'는 개발 시 필요한 고민이나
염두에 두어야 하는 일이라고 생각할 수 있는데, 코드를 작성하면서 염두에 두는 일들은 주로 다음과 같다
-파라미터가 올바르게 들어왔을까?
-이 작업을 하는 사용자가 적절한 권한을 가진 사용자인가?
-이 작업에서 발생할 수 있는 모든 예외는 어떻게 처리해야 하는가?

위와 같은 고민들은 '핵심 로직'은 아니지만, 코드를 온전하게 만들기 위해서 필요한 고민들인데 전통적인 방식에서는 개발자가
반복적으로 이러한 고민을 코드에 반영하게 된다. AOP는 이러한 고민에 대한 문제를 조금 다른 방식으로 접근한다. AOP가 추구
하는 것은 '관심사의 분리'이다. AOP는 개발자가 염두에 두어야 하는 일들은 별도의 '관심사'로 분리하고, 핵심 비즈니스 로직만
을 작성할 것을 권장한다. 

'관심사'를 쉽게 생각해보면 약간의 '주변 로직'이라고 표현하고 싶다. 예를 들어 나눗셈을 구현한다고 치면 '핵심 로직'은 두개의
숫자를 나누는 것이지만, '주변 로직'은 0을 나누는 것이 아닌지 등을 체크하는 것이다. '관심사'는 바로 이런 가장 중요한 로직은
아니지만, 사전 조건이나 사후 조건 등이라고 간주할 수 있다.

AOP는 과거에 개발자가 작성했던 '관심사 + 비즈니스 로직'을 분리해서 별도의 코드로 작성하도록 하고, 실행할 때 이를 결합하는
방식으로 접근한다. 과거에 비즈니스 로직을 작성하면서 그 내부에 필요한 '관심사'를 처리하던 방식과 정반대의 접근 방식이라고
볼 수 있는데, 개발자가 작성한 코드와 분리된 관심사를 구현한 코드를 컴파일 혹은 실행시점에 결합시킨다. 실제 실행은 결합된
상태의 코드가 실행되기 때문에 개발자들은 핵심 비즈니스 로직에만 근거해서 코드를 작성하고, 나머지는 어떤 관심사들과 결합
할 것인지를 설정하는 것 만으로 모든 개발을 마칠 수 있게 된다.

예를 들어 AOP를 이용하면 작성된 모든 메서드의 실행 시간이 얼마인지를 기록하는 기능을 기존 코드의 수정없이도 작성할 수
있고, 잘못된 파라미터가 들어와서 예외가 발생하는 상황을 기존 코드의 수정없이도 제어할 수 있다. 스프링이 AOP를 지원한다
는 것이 스프링의 가장 중요한 특징 중에 하나로 말하게 된 이유 역시 별도의 복잡한 설정이나 제약 없이 스프링 내에서 간편하게
AOP의 기능들을 구현할 수 있기 때문이다.

⊙ AOP 용어들
AOP는 기존의 코드를 수정하지 않고, 원하는 기능들과 결합할 수 있는 패러다임이다. 
개발자의 입장에서 AOP를 적용한다는 것은 기존의 코드를 수정하지 않고도 원하는 관심사들을 엮을 수 있다는 점이다. Target에
해당하는 것이 바로 개발자가 작성한 핵심 비즈니스 로직을 가지는 객체이다.

Target은 순수한 비즈니스 로직을 의미하고, 어떠한 관심사들과도 관계를 맺지 않는다. 순수한 코어라고 볼 수 있다. Target을
전체적으로 감싸고 있는 존재를 Proxy라고 한다. Proxy는 내부적으로 Target을 호출하지만, 중간에 필요한 관심사들을 거쳐서
Target을 호출하도록 자동 혹은 수동으로 작성된다. Proxy의 존재는 직접 코드를 통해서 구현하는 경우도 있지만, 대부분의 경
우 스프링 AOP 기능을 이용해서 자동으로 생성되는 (auto-proxy) 방식을 이용한다. JoinPoint는 Target 객체가 가진 메서드이다.
외부에서의 호출은 Proxy 객체를 통해서 Target 객체의 JoinPoint를 호출하는 방식으로 이해할 수 있다.

JoinPoint는 Target이 가진 여러 메서드라고 보면 된다. Target에는 여러 메서드가 존재하기 때문에 어떤 메서드에 관심사를 결합
할 것인지를 결정해야 하는데 이 결정을 'Pointcut'이라고 한다.

Pointcut은 관심사와 비즈니스 로직이 결합되는 지점을 결정하는 것이다. 앞의 Proxy는 이 결합이 완성된 상태이므로 메서드를
호출하게 되면 자동으로 관심사가 결합된 상태로 동작하게 된다. 관심사는 Aspect와 Advice라는 용어로 표현되어 있다.
Aspect는 조금 추상적인 개념을 의미한다. Aspect는 관심사 자체를 의미하는 추상명사라고 볼 수 있고, Advice는 Aspect를 구현
한 코드이다.

Advice는 실제 걱정거리를 분리해 놓은 코드를 의미한다. Advice는 그 동작 위치에 따라 다음과 같이 구분된다.
Before Advice : Target의 JoinPoint를 호출하기 전에 실행되는 코드이다. 코드의 실행 자체에는 관여할 수 없다.
After Returning Advice : 모든 실행이 정상적으로 이루어진 후에 동작하는 코드이다.
After Throwing Advice :  예외가 발생한 뒤에 동작하는 코드이다.
After Advice: 정상적으로 실행되거나 예외가 발생했을 때 구분 없이 실행되는 코드이다.
Around Advice: 메서드의 실행 자체를 제어할 수 있는 가장 강력한 코드이다. 직접 대상 메서드를 호출하고 결과나 예외를 처리
할 수 있다.

Adivce는 과거의 스프링에서는 별도의 인터페이스로 구현되고, 이를 클래스로 구현하는 방식으로 제작했으나 스프링 3버전 이후
에는 어노테이션만으로도 모든 설정이 가능하다. Target에 어떤 Advice를 적용할 것인지는 XML을 이용한 설정을 이용할 수 있고,
어노테이션을 이용하는 방식을 이용할 수 있다. 

Pointcut은 Adivce를 어떤 JoinPoint에 결합할 것인지를 결정하는 설정이다. AOP에서 Target은 결과적으로 Pointcut에 의해서
자신에게는 없는 기능들을 가지게 된다. Pointcut에 의해서 자신에게 없는 기능들을 가지게 된다. Pointcut은 다향한 형태로
선언해서 사용할 수 있는데 주로 사용되는 설정은 다음과 같다.
execution(@execution) : 메서드를 기준으로 Pointcut을 설정한다.
within(@within) : 특정한 타입(클래스)을 기준으로 Pointcut을 설정한다.
this : 주어진 인터페이스를 구현한 객체를 대상으로 Pointcut을 설정한다.
args(@args) : 특정한 파라미터를 가지는 대상들만을 Pointcut으로 설정한다.
@annotation : 특정한 어노테이션이 적용된 대상만을 Pointcut으로 설정한다

⊙AOP 실습
AOP 기능은 주로 일반적인 Jav API를 이용하는 클래스(POJO-Plain Old Java Object)들에 적용한다. Controller에 적용이 불가능한
것은 아니지만, Controller의 경우 뒤에서 학습하게 될 인터셉터나 필터 등을 이용한다. 예제에서는 서비스 계층에 AOP를 적용한다
AOP 예제는 1) 서비스 계층의 메서드 호출 시 모든 파라미터들을 로그로 기록하고, 2) 메서드들의 실행 시간을 기록하도록 한다.

⊙args를 이용한 파라미터 추적
LogAdvice가 SampleService의 doAdd()를 실행하기 직전에 간단한 로그를 기록하지만, 상황에 따라서는 해당 메서드에 전달되는
파라미터가 무엇인지 기록하거나, 예외가 발생했을 때 어떤 파라미터에 문제가 있는지 알고 싶은 경우도 많다.
LogAdvice에 적용된 @Before("execution(*org.zerock.service.SampleService*.*(..))")은 어떤 위치에 Advice를 적용할 것인지를 
결정하는 Pointcut인데, 설정 시에 args를 이용하면 간단히 파리미터를 구할 수 있다.



스프링에서 트랜잭션 관리

비즈니스에서는 쪼개질 수 없는 하나의 단위 작업을 말할 때 '트랜잭션'이라는 용어를 사용한다. 사전적인 의미로는 트랜잭션은
'거래'라는 뜻을 가지지만, 현실적으로는 '한 번에 이루어지는 작업의 단위'를 트랜잭션으로 간주한다.

트랜잭션의 성격을 'ACID원칙'으로 설명하곤 하는데 다음과 같다

원자성(Atomicity) - 하나의 트랜잭션은 모두 하나의 단위로 처리되어야 한다. 좀 더 쉽게 말하자면 어떤 트랜잭션이 A와 B로 
구성된다면 항상 A,B의 처리 결과는 동일한 결과이어야 한다. 즉 A는 성공했지만, B는 실패할 경우 A,B는 원래 상태로 되돌려
져야만 한다. 어떤 작업이 잘못되는 경우 모든 것은 다시 원점으로 되돌아가야만 한다.

일관성(Consistency) - 트랜잭션이 성공했다면 데이터베이스의 모든 데이터는 일관성을 유지해야만 한다. 트랜잭션으로 처리된
데이터와 일반 데이터 사이에는 전혀 차이가 없어야 한다.

격리(Isolation) - 트랜잭션으로 처리되는 중간에 외부에서의 간섭은 없어야만 한다.

영속성(Durability) - 트랜잭션이 성공적으로 처리되면 그 결과는 영속적으로 보관되어야 한다.

트랜잭션에서 가장 흔한 예제는 '계좌 이체'이다. '계좌 이체'라는 행위가 내부적으로는 하나의 계좌에서 출금이 이루어져야 하고,
이체의 대상 계좌에서는 입금이 이루어져야만 한다. '계좌 이체'는 엄밀하게 따져보면 '출금'과 '입금'이 각각의 거래가 하나의 단
위를 이루게 되는 상황이다.

비즈니스에서 하나의 트랜잭션은 데이터베이스 상에서는 하나 혹은 여러 개의 작업이 같은 묶음을 이루는 경우가 많다. 예를 들어
비즈니스 계층에서 '계좌 이체'는 bankTransfer()라는 메서드로 정의되고, 계좌 내에서 입금과 출금은 deposit()(입금), withdraw()(출금)
이라는 메서드로 정의된다고 가정해 본다.

deposit()과 withdraw()는 각자 고유하게 데이터 베이스와 커넥션을 맺고 작업을 처리한다. 문제는 withdraw()는 정상적으로 처리
되었는데, deposit()에서 예외가 발생하는 경우이다. 이미 하나의 계좌에서는 돈이 빠져나갔지만, 상대방의 계좌에는 돈이 입금되
지 않은 상황이 될 수 있다.

'트랜잭션으로 관리한다.' 혹은 '트랜잭션으로 묶는다'는 표현은 프로그래밍에서는 'AND'연산과 유사하다.

영속계층에서 withdraw()와 deposit()은 각각 데이터베이스와 연결을 맺고 처리하는데 하나의 트랜잭션으로 처리해야 할 경우에
는 한쪽이 잘못되는 경우에 이미 성공한 작업까지 다시 원상태로 복구되어야 한다. 별도의 패턴이나 프레임워크를 사용하지
않는 순수하게 JDBC를 이용하는 코드람녀 withdraw()와 deposit()의 내부는 아래와 같이 Connection을 맺고 처리하도록 작성될
것이다

public booleadn deposit(){
	Connection con = ....
	try{
		con = ...
	}catch(Execption e){
	}
	finally{
		try{con.close();}
	}
}
public booleadn withdraw(){
	Connection con = ....
	try{
		con = ...
	}catch(Execption e){
	}
	finally{
		try{con.close();}
	}
}
withdraw()와 deposit()이 위와 같이 고유하게 연결을 맺고 처리되는 구조라면 bankTransfer()를 작성할 때는 어느 한쪽이 실패할
때를 염두에 두고 코드를 복잡하게 만들어야 한다. 스프링은 이러한 트랜잭션 처리를 간단히 XML 설정을 이용하거나, 어노테이션
 처리만으로 할 수 있다.

데이터베이스 설계와 트랜잭션
데이터베이스의 저장 구조를 효율적으로 관리하기 위해서 흔히 '정규화'라는 작업을 한다. '정규화'의 가장 기본은 '중복된 데이터
를 제거'해서 데이터 저장의 효율을 올리자는 것이다. 정규화를 진행하면 1) 테이블은 늘어나고, 2) 각 테이블의 데이터 양은 줄어
드는 것이 일반적이다.

정규화를 진행하면서 원칙적으로 칼럼으로 처리되지 않는 데이터는 다음과 같다
*시간이 흐르면 변경되는 데이터를 칼럼으로 기록하지 않는다. - 데표적으로 사용자의 생년월일의 경우 칼럼에 기록하지만, 현재
나이는 칼럼으로 유지하지 않는다.(만일 나이에 대한 연산이 너무 빈번한 경우에는 칼럼으로 설정한 가능성도 있다)
*개선이 가능한 데이터를 칼럼으로 기록하지 않는다. - 주문과 주문 상세가 별도의 테이블로 분리되어 있다면 사용자가 한 번에
몇 개의 상품을 주문했는지 등을 칼럼으로 기록하지 않는다.(집합 연산이 성능에 영향을 주는 경우에만 칼럼으로 고려)
* 누구에게나 정해진 값을 이용하는 경우 데이터베이스에서 취급하지 않는다 - 예를 들어 2018년 1월 1일은 '월요일'이었고,이 
사실은 동일한 시간대를 사용하는 모든 사람들에게는 통용되기 때문에 데이터베이스에 기록하지 않는다.

정규화가 잘 되었거나, 위와 같은 규칙들이 반영된 데이터베이스의 설계에서는 '트랜잭션'이 많이 일어나지는 않는다. 정규화가 
진행될수록 테이블은 점점 더 순수한 형태가 되어가는데, 순수한 형태가 될수록 '트랜잭션 처리'의 대상에서 멀어진다. 정규화를
진행할수록 테이블은 더욱 간결해지지만 반대로 쿼리 등을 이용해서 필요한 데이터를 가져오는 입장에서는 점점 불편해 진다.
현재 상황을 알기 위해서는 단순히 조회를 하는 것이 아니라 직접 조인(join)이나 서브쿼리(subquery)를 이용해서 처리해야 하기
때문이다.

조인이나 서브쿼리를 이용하게 되면 다시 성능의 이슈가 발생할 수 있다. 매번 계산이 발생하도록 만들어지는 쿼리의 경우 성능
이 저하되기 때문에 많은 양의 데이터를 처리해야 하는 상황에서는 바람직하지 않을 수 있다. 이러한 상황에서는 흔히 '반정규화'
(역정규화)를 하게 된다. 정규화의 반대이므로 중복이나 계산되는 값을 데이터베이스 상에 보관하고, 대신에 조인이나 서브쿼리의
사용을 줄이는 방식이다.

반정규화의 가장 흔한 예가 '게시물의 댓글'의 경우이다. 정규화의 규칙을 따른다면 게시물 테이블과 댓글 테이블은 아래와 같은
구조를 가지는 것이 일반적이다.

BOOK_EX.TBL_BOARD				BOOK_EX.TBL_REPLY
P * BNO NUMBER(10)			  	P * RNO NUMBER(10)
   * TITLE VARCHAR2(200 BYTE)	            ↙	F * BNO NUMBER(10)
   * CONTENT VARCHAR2(2000 BYTE)    <-------	 -	  * REPLY VARCHAR2(1000 BYTE)
   * WIRITER VARCHAR2(50 BYTE)		↖	    REPLYDATE DATE
     REGDATE DATE					    UPDATEDATE DTAE			
     UPDATEDATE DATE
	
PK_BOARD(BNO)					PK_REPLY(RNO)
PK_BOARD(BNO)					FK_REPLY_BOARD(BNO)
						PK_REPLY(RNO)

정규화를 했다면 tbl_board 테이블에는 위와 같이 게시물에 대한 정보들만으로 칼럼이 구성되어야 하고, tbl_reply 테이블을 이용
해서 댓글들을 보관하게 된다. 문제는 게시물의 목록 페이지에서 일반적으로 댓글의 숫자도 같이 표시된다는 데 있다. 댓글을
추가한 뒤에 댓글의 숫자를 표시하려면 조인을 하거나 서브쿼리를 이용해서 처리하게 된다. 이러한 상황에서는 흔히 tbl_board
테이블에 댓글의 숫자를 칼럼으로 처리하는 경우가 많다. 댓글의 숫자를 칼럼으로 처리하게 되면 게시물의 목록을 가져올 경우
에는 tbl_reply 테이블을 이용해야 하는 일이 거의 없기 때문에 성능상으로 좀 더 이득을 볼 수 있게 된다.

반정규화는 이처럼 중복이나 계산의 결과를 미리 보관해서 좀 더 빠른 결과를 얻기 위한 노력이다. 반정규화를 하게 되면 쿼리가
단순해지고 성능상으로도 얻을 수 있는 이득이 있지만, 대신에 댓그링 추가될 때에는 댓글을 의미하는 tbl_reply 테이블에 insert
하고, 댓글의 숫자는 tbl_board테이블에 update를 시켜주는 작업이 필요하다. 두 작업은 하나의 트랜잭션으로 관리되어야 하는
작업이다.

PART6 파일 업로드 처리
대부분의 웹 프로젝트는 사용자가 첨부파일을 추가 할 수 있는 기능이 있다. 초기에는 단순히 <form>태그를 이용해서 첨부파일을 게시물 
작성과 같은 시점에 처리하는 방식을 사용했지만, 최근에는 첨부파일을 별도로 업로드해서 사용자가 최종적으로 게시물을 등록하기 전에
어떤 파일들을 업로드하는지 알 수 있는 방식을 사용한다.

첨부파일에 대한 처리는 흔히 업로드가 전부라고 생각하지만, 현실적으로 업로드된 이후에 처리가 상당히 복잡하다. 예를 들어 이미지 파일
의 경우네는 화면에 작은 섬네일 이미지를 생성해서 보여주어야 하고, 일반 파일의 경우에는 첨부파일이 존재한다는 아이콘만을 보여주어야 
한다. 또한 이미지의 경우는 대부분 클릭해서 원본 이미지를 확인 할 수 있게 하지만, 반면에 일반 파일의 경우에는 단순히 다운로드만을
처리해야 한다.

◆파일 업로드 방식

첨부파일을 서버에 전송하는 방식은 크게 <form> 태그를 이용해서 업로드하는 방식과 Ajax를 이용하는 방식으로 나눠볼 수 있다.

브라우저상에서 첨부파일에 대한 처리방법
⊙<form> 태그를 이용하는 방식: 브라우저의 제한이 없어야 하는 경우에 사용
-일반적으로 페이지 이동과 동시에 첨부파일을 업로드하는 방식
-<iframe>을 이용해서 화면의 이동없이 첨부파일을 처리하는 방식
⊙Ajax를 이용하는 방식: 첨부파일을 별도로 처리하는 방식
-<input type='file'>을 이용하고 Ajax로 처리하는 방식
-HTML5의 Drag And Drop 기능이나 jQurey 라이브러리를 이용해서 처리하는 방식

브라우저 상에서 첨부파일을 처리하는 방식은 다양하게 있지만, 서버 쪽에서의 처리는 거의 대부분 비스하다. 응답을 HTML 코드로 하는지
아니면 JSON 등으로 처리하느지 정도의 구분만 하면 된다. 

서버에서 주의해야 하는 점은 첨부파일의 처리를 위해서 어떤 종류의 라이브러리나 API등을 활용할 것인지에 대한 부분이다. 서버에서 첨부
파일을 처리하는 방식은 크게 다음과 같은 API들을 사용ㅎ나다.
⊙cos.jar: 2002년도 이후에 개바이 종료되었으므로, 더 이상 사용하는 것을 권장하지 않음
⊙commoms-fileupload: 가장 일반적으로 많이 활용되고, 서블릿 스펙 3.0 이전에도 사용 가능
⊙서블릿 3.0이상 - 3.0 이상부터는 자체적으로 파일 업로드 처리가 API상에서 지원

위의 방식에서 가장 일반적인 형태는 commons-fileupload를 이용한 설정이지만, Tomcat 7버전 이후에는 서블릿 3.0 이상을 지원하
므로, 이를 활용하는 방식으로 설정 사용. 첨부파일은 실제 서버가 동작하는 머신 내에 있는 폴더에 업로드 시켜야 하므로 C드라이브 밑에 
upload폴더와 임시 업로드 파일을 저장할 temp폴더를 생성.

첨부파일을 저장할 때 신경 쓰이는 것은 크게 두가지로 1) 중복된 이름의 파일 처리와 2) 한 폴더 내에 너무 많은 파일의 생성 문제이다.

1)의 경우는 현재 시간을 밀리세컨드(천분의 1초단위)까지 구분해서 파일 이름을 생성해서 저장하거나 UUOD를 이용해서 중복이 발생할 가능
성이 거의 없는 문자열을 생성해서 처리한다. 2)의 경우는 하나의 폴더에 생성될 수 있는 파일의 개수에 대한 문제인데, 한 폴더에 너무 많은
파일이 있는 경우 속도의 저하와 개수의 제한 문제가 생기는 것을 방지 해야 한다. 이에 대한 해결책으로 일반적인 방법은 '년/월/일'단위의
폴더를 생성해서 파일을 저장하는 것이다.

년/월/일 폴더의 생성
첨부파일을 보관하는 폴더를 생성하는 작업은 한 번에 폴더를 생성하거나 존재하는 폴더를 이용하는 방식을 사용한다. java.io.File에
존재하는 mkdirs()를 이용하면 필요한 상위 폴더까지 한 번에 생성할 수 있으므로 간단히 처리할 수 있다.

UploadController에 추가적인 메서드와 수정을 통해서 업로드 폴더 등을 처리한다.

◆섬네일 이미지 생성

이미지의 경로에 대한 처리와 중복 이름에 대한 처리가 완료되었다면, 남은 작업은 일반 파일과 이미지 파일을 구분하는 것이다. 이미지 파일
의 경우에는 화면에 보여지는 작은 이미지(이하 섬네일)를 생성하는 추가적인 처리이다. 만일 용량이 큰 파일을 섬네일 처리하지 않는다면
모바일과 같은 환경에서 많은 데이터를 소비해야만 하므로 이미지의 경우는 특별한 경우가 아니라면 섬네일을 제작해야만 한다.

섬네일을 제작한는 방법은 여러 가지 방식이 있다. JDK1.4 부터는 ImageIO를 제공하기 때문에 이를 이용해서 원본 이미지의 크기를 줄
일 수도 있고, ImagScalr와 같은 별도의 라이브러리를 이용하는 방식도 있다. JDK에 포함된 API를 이용하는 방식보다는 별도의 라이
브러리를 사용하는 경우가 많은데, 이는 이미지를 축소했을 때의 크기나 해상도를 직접 조절하는 작업을 줄이기 위해서이다.
Thumbnailator 라이브러리를 이용해서 섬네일 이미지를 생성한다.

UploadController에서는 다음과 같은 단계를 이용해서 섬네일을 생성한다.
-업로드된 파일이 이미지 종류의 파일인지 확인
-이미지 파일의 경우에는 섬네일 이미지 생성 및 저장

◆이미지 파일의 판단
화면에서 약간의 검사를 통해서 업로드 되는 파일의 확장자를 검사하기는 하지만, Ajax로 사용하는 호출은 반드시 브라우저만을 통해서 들어
오는 것이 아니므로 확인할 필요가 있다. 서버에 업로드된 파일은 조금 시간이 걸리더라도 파일 자체가 이미지인지를 정확히 체크한 뒤에 저장하
는 것이 좋다.

◆업로드된 파일의 데이터 반환
첨부파일 데이터의 업로드가 완료되었지만, 아직도 많은 작업이 남았다. Ajax를 이용해서 파일을 업로드했지만, 아직 브라우저 쪽에 아무런
데이터도 전달하지 않았기 때문에 브라우저에서는 어떠한 피드백도 받을 수 없는 상황이다. 서버에서 Ajax의 결과로 전달해야 하는 데이터는
업로드된 파일의 경로가 포함된 파일의 이름이다. 섬네일의 경우에는 's_'로 시작한다는 규칙만 알고 있으면 필요할 때 사용할 수 있다.

브라우저로 전송해야 하는 데이터는 다음과 같은 정보를 포함하도록 설계해야 한다.
-업로드된 파일의 이름과 원본 파일의 이름
-파일이 저장된 경로
-업로드된 파일이 이미지인지 아닌지에 대한 정보

이에 대한 모든 정보를 처리하는 방법은 1)업로드된 경로가 포함된 파일 이름을 반환하는 방식과 2) 별도의 객체를 생성해서 처리하는 방법을 고
려할 수 있다. 1)의 경우에는 브라우저 쪽에서 해야 하는 일이 많기 때문에 2)의 방식으로 구성하도록 한다.

◆브라우저에서 섬네일 처리
브라우저에서 첨부파일의 업로드 결과가 JSON 객체로 반환되었다면, 남은 작업은 당ㅁ과 같다.
-업로드 후에 업로드 부분을 초기화 시키는 작업
-결과 데이터를 이용해서 섬네일이나 파일 이미지를 보여주는 작업

현재 업로드는 <input type='file'>을 통해서 이루어지기 때문에 한 번 업로드가 끝난 후에는 이를 초기화 시켜주는 작업과 업로드된 결과를 
화면에 반영해 줄 필요가 있다.

◆<input type='file'>의 초기화
<input type='file'>은 다른 DOM 요소들과 조금 다르게 readonly라 안쪽의 내용을 수정할 수 없기 때문에 별도의 방법으로 초기화 시
켜서 또 다른 첨부파일을 추가할 수 있도록 만들어야한다.

우선 첨부파일을 업로드하기 전에 아무 내용이 없는 <input type='file'> 객체가 포함된 <div>를 복사(clone)한다. 첨부파일을 업
로드한 뒤에는 복사된 객체를 <div> 내에 다시 추가해서 첨부파일 부분을 초기화시킨다.


◆첨부파일의 다운로드 혹은 원본 보여주기
첨부파일의 업로드가 처리되는 과정도 복잡하지만, 이를 사용자가 사용하는 과정 역시 신경써야 하는 일이 많다. 브라우제에서 보이는 첨부파일은
크게 1)이미지 종류와 2)일반 파일로 구분되므로 사용자의 첨부파일과 관련된 행위도 종류에 따라 다르게 처리되어야 한다. 

만일 첨부파일이 이미지인 경우에는 섬네일 이미지를 클릭했을 때 화면에 크게 원본 파일을 보여주는 형태로 처리되어야 한다.이 경우는 브라우저에서
새로운 <div> 등을 생성해서 처리하는 방식을 이용하는데 흔히 'light-box'라고 한다. 'light-box'는 jQurey를 이용하는 많은 플
러그인들이 있으므로, 이를 이용하거나 직접 구현할 수 있다. 

첨부파일이 이미지가 아닌 경우에는 기본은 다운로드이다. 사용자가 파일을 선택하면 다운로드가 실행되면서 해당 파일의 이름으로 다운로드가 가능
해야 한다.

◆첨부파일의 다운로드
이미지를 처리하기 전에 우선 좀 더 간단한 첨부파일의 다운로드부터 처리하도록 한다. 첨부파일의 다운로드는 서버에서 MIME 타입을 다운로드 타
입으로 지정하고, 적절한 헤더 메시지를 통해서 다운로드 이름을 처리한다. 이미지와 달리 다운로드는 MIME 타입이 고정되기 때문에 메서드는 아래
와 같이 시작하게 된다.
@GetMapping(value="/download", produces=MediaType.APPLIACTION_OCTET_STREAM_VALUE)
@ResponseBody
public ResponseEntity<Resource> downloadFile(String fileName){
	log.info("download file: "+ fileName);
	
	Resource resource = new FileSystemResource("c:\\upload\\"+fileName);
	
	log.info("resource: + resource);
	
	return null;
}


ResponseEntity<>의 타입은 byte[] 등을 사용할 수 있으나, 이번 예제에서는 org.springframework.core.io.Resource타입
을 이용해서 좀 더 간단히 처리하도록 한다.

MIME타입은 다운로드를 할 수 있는 'application/octet-stream'으로 지정하고, 다운로드 시 저장되는 이름은 'Content-Disposition'
을 이용해서 지정한다. 파일 이름에 대한 문자열 처리는 파일 이름이 한글인 경우 저장할 때 깨지는 문제를 막기 위해서 이다. 크롬 브라우저에서 C:\upload
폴더에 있는 파일의 확장자로 '/download?fileName=xxxx'와 같이 호출하면 브라우저는 자동으로 해당 파일을 다운로드하는 것을 볼 수 있다. IE계
열에서는 파일 다운로드가 호출이 안되는 문제가 발생한다.


◆IE/Edge 브라우저의 문제
첨부파일의 다운로드 시 Chrome 브라우저와 달리 IE에서는 한글 이름이 제대로 다운로드 되지 않는다. 이것은 'Content-Disposition'의 값을 처리
하는 방식이 IE의 경우 인코딩 방식이 다르기 때문이다. 

IE를 같이 서비스해야 한다면 HttpServletRequest에 포함된 헤더 정보들을 이용해서 요청이 발생한 브라우저가 IE계열인지 확인해서 다르게 처리하는 방
식으로 처리한다. HTTP 헤더 메세지 중에서 디바이스의 정보를 알 수 있는 헤더는 'User-Agen'값을 이용한다.(이를 이용해서 브라우저의 종류나 모바일인지
데스크톱인지 혹은 브라우저의 프로그램의 종류를 구분할 수 있다.)

기존의 downloadFile()은 'User-Agen'정보를 파라미터로 수집하고, IE에 대한 처리를 추가한다. Edge브라우저는 IE와 또 다르게 처리되므로 주의
 

◆원본 이미지 보여주기
일반 첨부파일과 달리 섬네일이 보여지는 이미지 파일의 경우 섬네일을 클릭하면 원본 이미지를 볼 수 있게 처리합니다. 
섬네일의 이미지가 '업로드된 경로 +/s_+UUID_+파일이름' 이었다면, 원본 이미지의 이름은 중간에 '/s_'가 '/'로 변경되는 점이 다르다. 
원본 이미지를 화면에 보기 위해서는 <div>를 생성하고, 해당 <div>에 이미지 태그를 작성해서 넣어주는 작업과 이를 화면상에서 절대 위치를 이용해서 보여줄
필요가 있다.

◆원본 이미지를 보여줄 <div>처리
이미지의 경우 일반 파일과 달리 이미 이미지 파일 데이터는 섬네일과 동일한 방식으로 처리될 수 있기 때문에 사실상 핵심적인 부분은 이미지를 보여주는 <div>를
처리하는 부분이 핵심이다.

<div>를 처리하는 부분은 섬네일 파일을 클릭할 때 이루어 지도록 JavaScript 함수를 작성한다.

원본 이미지 혹은 주변 배경을 선택하면 우선은 이미지를 화면 중앙으로 작게 점차 줄여준다(1초동안), jQuery의 애니메이션이 끝난 후 이벤트를 감지하는 방식
도 있지만, 예제는 1초 후에 자동으로 배경창을 안 보이도록 처리하는 방식을 이용한다.

setTimeout()에 적용된 '=>(ES6의 화살표 함수)'는 Chrome에서는 정상 작동하지만, IE 11에서는 제대로 동작하지 않으므로 필요하다면 변경해서 
사용한다.

◆첨부파일 삭제
첨부파일 삭제는 생각보다 많은 고민이 필요한 작업이다. 단순히 파일 하나만을 삭제한다고 생각할 수 있지만 실제로는 다음과 같은 문제점들을 고민해야 한다.
-이미지 파일의 경우에는 섬네일까지 같이 삭제되어야 하는 점
-파일을 삭제한 후에는 브라우저에서도 섬네일이나 파일 아이콘이 삭제되도록 처리하는 점
-비정상적으로 브라우저의 종료 시 업로드된 파일의 처리

◆일반 파일과 이미지 파일의 삭제
업로드된 첨부파일의 삭제는 Ajax를 이용하거나 <form> 태그를 이용하는 방식 모두를 적용할 수 있다. 이미 업로드된 첨부파일의 삭제는 일반 파일의 경우에는
업로드된 파일만 삭제하면 되지만, 이미지의 경우 생성된 섬네일 파일과 원본 파일을 같이 삭제해야 한다.

서버 측에서는 삭제하려는 파일의 확장자를 검사해서 일반 파일인지 이미지 파일인지를 파악하거나 파라미터로 파일의 종류를 파악하고, 이를 이용하여 처리를 다르게
한다.

◆첨부파일의 삭제 고민
첨부파일을 삭제하는 작업의 최대 고민은 사용자가 비정상적으로 브라우저를 종료하고 나가는 행위이다. 서버에는 Ajax를 이용해서 업로드 했기 때문에 이미 저장이 
된 상태지만, 사용자가 '작업관리자'나 전원 버튼을 누르는 등의 조치를 해서 브라우저 자체를 종료해 버린다면 이를 감지할 수 있는 적당한 방법이 없다.(브라우저의
창이 닫히는 이벤트는 가능하긴 하지만 비정상적인 종료는 문제가 된다)

이에 대한 가장 좋은 해결책은 실제 최종적인 결과와  서버에 업로드된 파일의 목록을 비교해서 처리하는 것이다. 보통 이런 작업은 spring-batch나 Quartz
라이브러리를 이용해서 처리한다.

◆프로젝트의 첨부파일-등록
첨부파일을 어떤 방식으로 처리하는지에 대한 학습이 완료되었다면 기존의 프로젝트에 첨부파일 기능을 추가하는 작업을 진행한다. 첨부파일은 게시물의 등록/조회/
수정/,삭제 화면에서 처리할 필요가 있으므로 각 단계마다 나누어서 개발을 진행한다. 개발을 위해서 현재 예제를 작성한 프로젝트에 기존 프로젝트의 설정이나 패키
지등을 먼저 복사해서 추가한 상태로 개발을 시작한다.

◆첨부파일 정보를 위한 준비
첨부파일이 게시물과 합쳐지면 가장 먼저 진행해야 하는 일은 게시물과 첨부파일의 관계를 저장하는 테이블의 설계가 우선이다. 게시물의 첨부파일은 각자 고유한
UUID를 가지고 있기 때문에 별도의 PK를 지정할 필요는 없지만, 게시물을 등록할 때 첨부파일 테이블 역시 같이 insert 작업이 진행되어야 하므로 트랜잭션
처리가 필요하다.

첨부파일을 보관하는 테이블은 tbl_attach로 설계한다. tbl_board는 tbl_reply와 이미 외래키의 관계를 가지고 있으므로 첨부파일이 추가되면 아래와
같은 구조가 된다.
create table tbl_attach(
	uuid varchar2(100) not null,
	uploadPath varchar2(200) not null,
	fileName varchar2(100) not null,
	filetype char(1) default 'I',
	bno number(10,0)
);

alter table tbl_attach add constraint pk_attach primary key(uuid);

alter table tbl_attach add constraint fk_board_attach foreign key(bno) references tbl_board(bno);

첨부파일의 보관은 UUID가 포함된 이름을 PK로 하는 uuid칼럼과 실제 파일 업로드된 경로를 의미하는 uploadPath, 파일 이름을 의미하는 fileName,이미
지 파일 여부를 판단할 수 있는 fileType, 해당 게시물 번호를 저장하는 bno 칼럼을 이용한다.

SQL을 처리하기 위해서는 파일 정보를 처리하기 위해 파라미터를 여러 개 사용해야 하는 불편함이 있으므로, org.zerock.domain 패키지에 아에 BoardAttachVO
클래스를 설계하는 것이 유용하다(AttachFileDTO와 거의 유사하지만 게시물의 번호가 추가되었고, 혼란을 피하기 위해서 새로운 클래스를 작성).

◆등록을 위한 화면 처리
첨부파일 자체의 처리는 Ajax를 통해서 이루어지므로, 게시물의 등록 시점에는 현재 서버에 업로드된 파일들에 정보를 등록하려는 게시물의 정보와 같이 전송해서
처리한다. 이 작업은 게시물의 등록 버튼을 클릭했을 때 현재 서버에 업로드된 파일의 정보를 <input type='hidden'>으로 만들어서 한번에 전송하는 방식을
사용한다.

◆게시물 등록과 첨부파일의 데이터베이스 처리
게시물의 등록 과정에서는 첨부파일의 상세 조회는 의미가 없고, 단순히 새로운 첨부파일을 추가하거나 삭제해서 자신이 원하는 파일을 게시물 등록할 때 같이 포함하도록
한다. Ajax를 이용하는 경우 이미 어떠한 파일을 첨부로 처리할 것인지는 이미 완료된 상태이므로 남은 작업은 게시물이 등록될 때 첨부파일과 관련된 자료를 같이 전송하고
이를 데이터베이스에 등록하는 것이다. 게시물의 등록은 <form> 태그를 통해서 이루어지므로, 이미 업로드된 첨부파일의 정보는 별도의 <input type='hidden'>
태그를 생성해서 처리한다.

이를 위해서 첨부파일 정보를 태그로 생성할 때 첨부파일과 관련된 정보(data-uuid, data-fileName, data-type)를 추가한다.

BoardVO에는 attachList라는 이름의 변수로 첨부파일의 정보를 수집하기 때문에 <input type='hidden'>의 name은 'attachList[인덱스번호]'와 같은
이름을 사용하도록 한다.

◆게시물의 조회와 첨부파일
게시물의 조회에서는 첨부파일을 다운로드하거나 원본 이미지의 파일을 볼 수 있는 기능을 사용하게 된다. 게시물의 조회에서 고민해야 하는 내용은 첨부파일을 한 번에 볼 것
인지, Ajax를 이용해서 별도로 처리할 것인지에 대한 결정이다.

게시물의 정보는 tbl_board 테이블에 기록되어 있고, 첨부파일의 정보는 tbl_attach에 기록되어 있기 때문에 화면에서 두 테이블에 있는 정보를 사용하기 위해서는
다음과 같은 방식을 고려
-BoardVO 객체를 가져올 때 join을 처리해서 한꺼번에 게시물과 첨부파일의 정보를 같이 처리하는 방식. 데이터베이스를 한 번만 호출하게 되므로 효율적이지만 MyBatis
쪽에서 처리해야 하는 일이 많아진다.
-JSP에서 첨부파일의 정보를 Ajax를 이용해서 처리하는 방식이다.다시 쿼리를 처리해야 하는 불편함이 있지만 난이도가 낮고, 화면에서 처리는 JavaScript가 복잡함

위의 방식들 중에서 전통적인 방식은 쿼리를 이용해서 두 개의 테이블을 join해서 처리하는 방식이다. 쿼리를 한 번만 실행하기 때문에 데이터베이스의 부하를 줄여줄 수 있
다는 장점이 있다. join을 이용해서 하나의 객체를 구성하는 방식은 조금 뒤쪽에서 알아본다.

◆게시물의 삭제와 첨부파일

BoardController는 데이터베이스의 삭제를 먼저 호출하고, 이후 파일을 삭제해야 한다. 다만 파일을 삭제하기 위해서는 해당 게시물의 첨부파일 목록이 필요하다.
문제는 첨부파일의 목록을 구한다고 해도 이미지 파일의 경우에는 섬네일 파일이 생성되어 있으므로 이에 대한 처리가 필요하다는 점이다.
-해당 게시물의 첨부파일 정보를 미리 준비
-데이터베이스 상에서 해당 게시물과 첨부파일 데이터 삭제
-첨부파일 목록을 이용해서 해당 폴더에서 섬네일 이미지(이미지 파일의 경우)와 일반 파일을 삭제


◆게시물의 수정과 첨부파일

게시물을 수정할 때 첨부파일과 관련된 작업은 사실상 게시물 등록 작업과 상당히 유사하다. 첨부파일이라는 개념 자체가 수정이 아닌 기존 파일을 삭제하고, 새로운 파일을 추가
하기 때문이다. 게시물 수정에서 첨부파일은 수정이라는 개념보다는 삭제 후 다시 추가한다는 개념으로 접근해야 한다. 게시물의 수정에는 기존의 게시물 테이블을 수정하는 
작업과 변경(새롭게 추가된)된 첨부파일을 등록하는 작업으로 이루어진다.

◆화면에서 첨부파일수정
수정은 views 폴더 내에 /board/modify.jsp에서 이루어진다. 게시물의 수정은 게시물의 조회화면과 유사하지만 1)원본 이미지 확대나 다운로드 기능이 필요하지 
않다는 점, 2)게시물 조회와 달리 삭제 버튼이 있어야 하는 점이 다르다.

◆잘못된 업로드된 파일 삭제
Ajax를 이용해서 첨부파일을 사용하면 사용자가 게시물을 등록하거나 수정하기 전에 미리 업로드시킨 파일들을 볼 수 있다는 장점이 있지만, 다음과 같은 문제발생
-첨부파일만을 등록하고 게시물을 등록하지 않았을 때의 문제 -파일은 이미 서버에 업로드되었지만, 게시물을 등록하지 않았으므로 의미 없이 파일들만 서버에 업로드된 상황
-게시물을 수정할 때 파일을 삭제했지만 실제로 폴더에서 실제로 폴더에서 기존 파일은 삭제 되지 않은 문제 -데이터베이스에서는 기존 파일이 삭제되었지만, 실제 폴더에는
남는 문제

위 상황의 공통적인 문제는 사용자가 Ajax로 어떤 작업을 한 후에 비정상적으로 브라우저를 종료하거나 페이지를 빠저나가는 문제이다. 이 문제를 해결하는 핵심은 정상적으로
사용자의 게시물에 첨부된 파일인지 아니면 사용자가 게시물을 수정할 때 업로드했지만 최종적으로 사용되는 파일인지 아닌지를 파악하는 것이 핵심

◆잘못 업로드된 파일의 정리
게시물에 필요한 모든 파일에 대한 정보는 최종적으로는 데이터베이스에 기록되어 있다. 만일 사용자가 게시물을 등록하거나 수정하기 위해서 첨부파일을 등록했지만. 최종적
으로  submit을 하지 않은 경우에는 폴더에 파일들은 업로드되지만, 데이터베이스에는 아무 변화 없게 된다.

만일 정상적으로 해당 첨부파일이 게시물에 사용된다면 데이터베이스의 tbl_attach 테이블에 기록되어 있을 것이므로 데이터베이스와 비교하는 작업을 거쳐서 업로드만 된 
파일의 목록을 찾아야 한다.

◆Quartz 라이브러리 설정
Quartz 라이브러리는 일반적으로 스케줄러를 구성하기 위해서 사용한다. 서버를 운영하기 위해서는 간혹 주기적으로 매일, 매주, 매월 등 주기적으로 특저한 프로그램을
실행할 필요가 있다. 이 작업은 운영체제의 기능을 이용해서 작업할 수도 있지만, 스프링과 Quartz라이브러리를 이용하면 간단히 처리할 수 있다. 