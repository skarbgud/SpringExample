if
if는 test라는 속성과 함께 특정한 조건이 true가 되었을때 포함된 SQL을 사용하고자 할 때 작성
제목 내용 작성자에 대해 검색해야 하는 상황이라고 가정
검색조건이 T이면 제목검색
검색조건이 C이면 내용검색
검색조건이 W이면 작성자검색

<if test="type == 'T'.toString()">
	(title like '%' || #{keyword} || '%')
</if>


<if test="type == 'C'.toString()">
	(content like '%' || #{keyword} || '%')
</if>
<if test="type == 'W'.toString()">
	(writer like '%' || #{keyword} || '%')
</if>

if안에 들어가는 표현식은 OGNL표현식이라는것을 이용합니다.

<choose>
if와 달리 choose는 여러 상황들 중 하나의 상황에서만 동작한다

<choose>
<when test="type == 'T'.toString()">
	(title like '%' ||#{keyword}||'%')
</when>
<when test="type == 'C'.toString()">
	(content like '%' ||#{keyword}||'%')
</when>
<when test="type == 'W'.toString()">
	(writer like '%' ||#{keyword}||'%')
</when>
<oherwise>
	(title like '%'||#{keyword}||'%' OR content like '%'||#{keyword}||'%')
</oherwise>
</choose>

trim, where, set 은 단독으로 사용되지 않고, if나 choose와 같은 태그들을 내포하여 SQL들을 연결해주고, 앞뒤에 필요한 구문들(AND, OR, WHERE)을 추가하거나 생
략하는 역할을 한다. 

URI(Uniform Resource Identifier) 자원의 식별자
URL은 '이 곳에 가면 당신이 원하는 것을 찾을 수 있습니다.'와 같은 상징적인 의미가 좀 더 강하다면, URI는 '당신이 원하는 곳의
주소는 여깁니다.와 같이 좀 더 현실적이고 구체적인 의미가 있다.

REST는 'Representational State Transfer'의 약어로 하나의 URI는 하나의 고유한 리소스를 대표하도록 설계된다는 개념에
전송방식을 결합해서 원하는 작업을 지정합니다. 
예를 들어 '/board/123'은 게시물 중에서 123번이라는 고유한 의미를 가지도록 설계하고, 이에 대한 처리는 GET, POST 방식과
같이 추가적인 정보를 통해서 결정한다. 
URI + GET/POST/PUT/DELETE/....

스프링은 @RequestMapping이나 @ResponseBody와 같이 REST 방식의 데이터 처리를 위한 여러종류의 어노테이션과 기능이
있다. Rest와 관련해서 알아 두어야 하는 어노테이션

@RestController - Controller가 REST 방식을 처리하기 위한 것임을 명시한다.
@ResponseBody - 일반적인 JSP와 같은 뷰로 전달되는 게 아니라 데이터 자체를 전달하기 위한 용도
@PathVariable - URL 경로에 있는 값을 파라미터로 추출하려고 할 때 사용
@CrossOrigin - Ajax의 크로스 도메인 문제를 해결해주는 어노테이션
@RequestBody - JSON 데이터를 원하는 타입으로 바인딩 처리

@RestController
-REST방식에서 가장 먼저 기억해야 하는 점은 서버에서 전손하는 것이 순수한 데이터라는 점.
기존의 Controller에서 Model에 데이터를 담아서 JSP 등과 같은 뷰로 전달하는 방식이 아니므로 기존의 Controller와 조금 다르다

스프링 4에서부터는 @Controller외에 @RestController라는 어노테이션을 추가해서 해당 Controller의 모든 메서드의 리턴
타입을 기존과 다르게 처리한다는 것을 명시한다.
@RestController 이전에는 @Contoller와 메서드 선언부에 @ResponseBody를 이용해서 동일한 결과를 만들 수 있다
@RestController는 메서드의 리턴 타입으로 사용자가 정의한 클래스 타입을 사용할 수 있고, 이를 JSON이나 XML로 자동 처리
할 수 있다.

JSON은 'JavaScript Object Notatiton'의 약어로 구조가 있는 데이터를 '{}'로 묶고 '키'와 '값'으로 구성하는 경량의 데이터 포맷.
프로그래밍 언어에서 말하는 객체들의 구조는 '{}'를 이용해서 다음과 같이 표현할 수 있다.
{
	"이름":"홍길동",
	"나이":25,
	"성별":"여",
	"주소":"서울특별시 양천구 목동",
	"특기":["농구","도술"],
	""가족관계": {"#":2, "아버지" : "홍판서", "어머니": "춘섬"},
}
구조를 표현한 문자열은 프로그래밍 언어에 관계 없이 사용할 수 있기 때문에 XML과 더불어 가장 많이 사용되는 데이터 형태

@RestController는 기존의 @Controller에서 사용하던 일반적인 타입이나 사용자가 정의한 타입(클래스)을 사용한다.
여기에 추가로 몇가지 어노테이션을 이용하는 경우가 있다.
-@PathVariable : 일반 컨트롤러에서도 사용이 가능하지만 REST 방식에서 자주 사용된다. URL 경로의 일부를 파라미터로 
사용할 때 이용
-@RequestBody : JSON 데이터를 원하는 타입의 객체로 변환해야 하는 경우 주로 사용

@PathVariable
REST방식에서는 URL 내에 최대한 많은 정보를 담으려고 노력한다. 예전에는 "?' 뒤에 추가되는 쿼리 스트링이라는 형태로
파라미터를 이용해서 전달되던 데이터들이 REST방식에서는 경로의 일부로 차용되는 경우가 많다

스프링 MVC에서는 @PathVariable 어노테이션을 이용해서 URL 상에 경로의 일부를 파라미터로 사용할 수 있다.

http://localhost:8089/sample/{sno}
http://localhost:8089/sample/{sno}/page/{pno}

위의 URL에서 '{}'로 처리된 부분은 컨트롤러의 메서드에서 변수로 처리가 가능하다
@PathVariable은 '{}'의 이름을 처리할 때 사용

REST 방식에서는 URL자체에 데이터를 식별할 수 있는 정보들을 표현하는 경우가 많으므로 다양한 방식으로 @PathVariable이
사용된다.


특정 댓글의 클릭 이벤트 처리
댓글은 댓글의 목록에서 내용이 모두 출력되기 때문에 별도로 클릭한다는 것은 해당 댓글을 수정하거나 삭제하는 경우에 발생
한다. 댓글의 수정과 삭제는 원칙적으로 로그인한 사용자가 해당 댓글의 작성자인 경우에만 허락되어야한다. 다만 현재까지 로
그인에 대해서는 처리된 적이 없으므로 코드에서는 어떠한 댓글도 수정/삭제가 되도록 작성

DOM에서 이벤트 리스너를 등록하는 것은 반드시 해당 DOM 요소가 존재해야만 가능하다. 위와 같이 동적으로 Ajax를 통해서
<li> 태그들이 만들어지면 이후에 이벤트를 등록해야 하기 때문에 일반적인 방식이 아니라 '이벤트 위임(delegation)'의 형태로
작성해야 한다.

'이벤트 위임'이 말은 거창하지만 실제로는 이벤트를 동적으로 생성되는 요소가 아닌 이미 존재하는 요소에 이벤트를 걸어주고,
나중에 이벤트의 대상을 변경해주는 방식이다. jQuery는 on()을 이용해서 쉽게 처리가 가능하다.

AOP(Aspect-Oriented Programming)는 '관점 지향 프로그래밍'이라는 의미로 번역되는데, 객체지향에서 특정 비즈니스 로직에
걸림돌이 되는 공통 로직을 제거할 수 있는 방법을 제공한다. AOP를 적용하면 기존의 코드에 첨삭 없이, 메서드의 호출 이전 혹은
이후에 필요한 로직을 수행하는 방법을 제공한다.

트랜잭션 작업은 데이터베이스를 이용할 때 '두개이상의 작업이 같이 영향을 받는 경우'에 필요하다.
과거에는 코드 내에 개발자가 직접 이를 지정하고 사용했다면 스프링에서는 XML이나 어노테이션만으로 트랜잭션이 처리된
결과를 만들어 낼 수 있다.

AOP는 흔히 '관점 지향 프로그래밍'이라는 용어로 번역되는데, 이 때 '관점'이라는 용어가 현실적으로 와닿지 않기 떄문에
어렵게 느껴질 수 있다. '관점'이라는 용어는 개발자들에게 '관심사'라는 말로 통용된다. '관심사'는 개발 시 필요한 고민이나
염두에 두어야 하는 일이라고 생각할 수 있는데, 코드를 작성하면서 염두에 두는 일들은 주로 다음과 같다
-파라미터가 올바르게 들어왔을까?
-이 작업을 하는 사용자가 적절한 권한을 가진 사용자인가?
-이 작업에서 발생할 수 있는 모든 예외는 어떻게 처리해야 하는가?

위와 같은 고민들은 '핵심 로직'은 아니지만, 코드를 온전하게 만들기 위해서 필요한 고민들인데 전통적인 방식에서는 개발자가
반복적으로 이러한 고민을 코드에 반영하게 된다. AOP는 이러한 고민에 대한 문제를 조금 다른 방식으로 접근한다. AOP가 추구
하는 것은 '관심사의 분리'이다. AOP는 개발자가 염두에 두어야 하는 일들은 별도의 '관심사'로 분리하고, 핵심 비즈니스 로직만
을 작성할 것을 권장한다. 

'관심사'를 쉽게 생각해보면 약간의 '주변 로직'이라고 표현하고 싶다. 예를 들어 나눗셈을 구현한다고 치면 '핵심 로직'은 두개의
숫자를 나누는 것이지만, '주변 로직'은 0을 나누는 것이 아닌지 등을 체크하는 것이다. '관심사'는 바로 이런 가장 중요한 로직은
아니지만, 사전 조건이나 사후 조건 등이라고 간주할 수 있다.

AOP는 과거에 개발자가 작성했던 '관심사 + 비즈니스 로직'을 분리해서 별도의 코드로 작성하도록 하고, 실행할 때 이를 결합하는
방식으로 접근한다. 과거에 비즈니스 로직을 작성하면서 그 내부에 필요한 '관심사'를 처리하던 방식과 정반대의 접근 방식이라고
볼 수 있는데, 개발자가 작성한 코드와 분리된 관심사를 구현한 코드를 컴파일 혹은 실행시점에 결합시킨다. 실제 실행은 결합된
상태의 코드가 실행되기 때문에 개발자들은 핵심 비즈니스 로직에만 근거해서 코드를 작성하고, 나머지는 어떤 관심사들과 결합
할 것인지를 설정하는 것 만으로 모든 개발을 마칠 수 있게 된다.

예를 들어 AOP를 이용하면 작성된 모든 메서드의 실행 시간이 얼마인지를 기록하는 기능을 기존 코드의 수정없이도 작성할 수
있고, 잘못된 파라미터가 들어와서 예외가 발생하는 상황을 기존 코드의 수정없이도 제어할 수 있다. 스프링이 AOP를 지원한다
는 것이 스프링의 가장 중요한 특징 중에 하나로 말하게 된 이유 역시 별도의 복잡한 설정이나 제약 없이 스프링 내에서 간편하게
AOP의 기능들을 구현할 수 있기 때문이다.

⊙ AOP 용어들
AOP는 기존의 코드를 수정하지 않고, 원하는 기능들과 결합할 수 있는 패러다임이다. 
개발자의 입장에서 AOP를 적용한다는 것은 기존의 코드를 수정하지 않고도 원하는 관심사들을 엮을 수 있다는 점이다. Target에
해당하는 것이 바로 개발자가 작성한 핵심 비즈니스 로직을 가지는 객체이다.

Target은 순수한 비즈니스 로직을 의미하고, 어떠한 관심사들과도 관계를 맺지 않는다. 순수한 코어라고 볼 수 있다. Target을
전체적으로 감싸고 있는 존재를 Proxy라고 한다. Proxy는 내부적으로 Target을 호출하지만, 중간에 필요한 관심사들을 거쳐서
Target을 호출하도록 자동 혹은 수동으로 작성된다. Proxy의 존재는 직접 코드를 통해서 구현하는 경우도 있지만, 대부분의 경
우 스프링 AOP 기능을 이용해서 자동으로 생성되는 (auto-proxy) 방식을 이용한다. JoinPoint는 Target 객체가 가진 메서드이다.
외부에서의 호출은 Proxy 객체를 통해서 Target 객체의 JoinPoint를 호출하는 방식으로 이해할 수 있다.

JoinPoint는 Target이 가진 여러 메서드라고 보면 된다. Target에는 여러 메서드가 존재하기 때문에 어떤 메서드에 관심사를 결합
할 것인지를 결정해야 하는데 이 결정을 'Pointcut'이라고 한다.

Pointcut은 관심사와 비즈니스 로직이 결합되는 지점을 결정하는 것이다. 앞의 Proxy는 이 결합이 완성된 상태이므로 메서드를
호출하게 되면 자동으로 관심사가 결합된 상태로 동작하게 된다. 관심사는 Aspect와 Advice라는 용어로 표현되어 있다.
Aspect는 조금 추상적인 개념을 의미한다. Aspect는 관심사 자체를 의미하는 추상명사라고 볼 수 있고, Advice는 Aspect를 구현
한 코드이다.

Advice는 실제 걱정거리를 분리해 놓은 코드를 의미한다. Advice는 그 동작 위치에 따라 다음과 같이 구분된다.
Before Advice : Target의 JoinPoint를 호출하기 전에 실행되는 코드이다. 코드의 실행 자체에는 관여할 수 없다.
After Returning Advice : 모든 실행이 정상적으로 이루어진 후에 동작하는 코드이다.
After Throwing Advice :  예외가 발생한 뒤에 동작하는 코드이다.
After Advice: 정상적으로 실행되거나 예외가 발생했을 때 구분 없이 실행되는 코드이다.
Around Advice: 메서드의 실행 자체를 제어할 수 있는 가장 강력한 코드이다. 직접 대상 메서드를 호출하고 결과나 예외를 처리
할 수 있다.

Adivce는 과거의 스프링에서는 별도의 인터페이스로 구현되고, 이를 클래스로 구현하는 방식으로 제작했으나 스프링 3버전 이후
에는 어노테이션만으로도 모든 설정이 가능하다. Target에 어떤 Advice를 적용할 것인지는 XML을 이용한 설정을 이용할 수 있고,
어노테이션을 이용하는 방식을 이용할 수 있다. 

Pointcut은 Adivce를 어떤 JoinPoint에 결합할 것인지를 결정하는 설정이다. AOP에서 Target은 결과적으로 Pointcut에 의해서
자신에게는 없는 기능들을 가지게 된다. Pointcut에 의해서 자신에게 없는 기능들을 가지게 된다. Pointcut은 다향한 형태로
선언해서 사용할 수 있는데 주로 사용되는 설정은 다음과 같다.
execution(@execution) : 메서드를 기준으로 Pointcut을 설정한다.
within(@within) : 특정한 타입(클래스)을 기준으로 Pointcut을 설정한다.
this : 주어진 인터페이스를 구현한 객체를 대상으로 Pointcut을 설정한다.
args(@args) : 특정한 파라미터를 가지는 대상들만을 Pointcut으로 설정한다.
@annotation : 특정한 어노테이션이 적용된 대상만을 Pointcut으로 설정한다

⊙AOP 실습
AOP 기능은 주로 일반적인 Jav API를 이용하는 클래스(POJO-Plain Old Java Object)들에 적용한다. Controller에 적용이 불가능한
것은 아니지만, Controller의 경우 뒤에서 학습하게 될 인터셉터나 필터 등을 이용한다. 예제에서는 서비스 계층에 AOP를 적용한다
AOP 예제는 1) 서비스 계층의 메서드 호출 시 모든 파라미터들을 로그로 기록하고, 2) 메서드들의 실행 시간을 기록하도록 한다.

⊙args를 이용한 파라미터 추적
LogAdvice가 SampleService의 doAdd()를 실행하기 직전에 간단한 로그를 기록하지만, 상황에 따라서는 해당 메서드에 전달되는
파라미터가 무엇인지 기록하거나, 예외가 발생했을 때 어떤 파라미터에 문제가 있는지 알고 싶은 경우도 많다.
LogAdvice에 적용된 @Before("execution(*org.zerock.service.SampleService*.*(..))")은 어떤 위치에 Advice를 적용할 것인지를 
결정하는 Pointcut인데, 설정 시에 args를 이용하면 간단히 파리미터를 구할 수 있다.



스프링에서 트랜잭션 관리

비즈니스에서는 쪼개질 수 없는 하나의 단위 작업을 말할 때 '트랜잭션'이라는 용어를 사용한다. 사전적인 의미로는 트랜잭션은
'거래'라는 뜻을 가지지만, 현실적으로는 '한 번에 이루어지는 작업의 단위'를 트랜잭션으로 간주한다.

트랜잭션의 성격을 'ACID원칙'으로 설명하곤 하는데 다음과 같다

원자성(Atomicity) - 하나의 트랜잭션은 모두 하나의 단위로 처리되어야 한다. 좀 더 쉽게 말하자면 어떤 트랜잭션이 A와 B로 
구성된다면 항상 A,B의 처리 결과는 동일한 결과이어야 한다. 즉 A는 성공했지만, B는 실패할 경우 A,B는 원래 상태로 되돌려
져야만 한다. 어떤 작업이 잘못되는 경우 모든 것은 다시 원점으로 되돌아가야만 한다.

일관성(Consistency) - 트랜잭션이 성공했다면 데이터베이스의 모든 데이터는 일관성을 유지해야만 한다. 트랜잭션으로 처리된
데이터와 일반 데이터 사이에는 전혀 차이가 없어야 한다.

격리(Isolation) - 트랜잭션으로 처리되는 중간에 외부에서의 간섭은 없어야만 한다.

영속성(Durability) - 트랜잭션이 성공적으로 처리되면 그 결과는 영속적으로 보관되어야 한다.

트랜잭션에서 가장 흔한 예제는 '계좌 이체'이다. '계좌 이체'라는 행위가 내부적으로는 하나의 계좌에서 출금이 이루어져야 하고,
이체의 대상 계좌에서는 입금이 이루어져야만 한다. '계좌 이체'는 엄밀하게 따져보면 '출금'과 '입금'이 각각의 거래가 하나의 단
위를 이루게 되는 상황이다.

비즈니스에서 하나의 트랜잭션은 데이터베이스 상에서는 하나 혹은 여러 개의 작업이 같은 묶음을 이루는 경우가 많다. 예를 들어
비즈니스 계층에서 '계좌 이체'는 bankTransfer()라는 메서드로 정의되고, 계좌 내에서 입금과 출금은 deposit()(입금), withdraw()(출금)
이라는 메서드로 정의된다고 가정해 본다.

deposit()과 withdraw()는 각자 고유하게 데이터 베이스와 커넥션을 맺고 작업을 처리한다. 문제는 withdraw()는 정상적으로 처리
되었는데, deposit()에서 예외가 발생하는 경우이다. 이미 하나의 계좌에서는 돈이 빠져나갔지만, 상대방의 계좌에는 돈이 입금되
지 않은 상황이 될 수 있다.

'트랜잭션으로 관리한다.' 혹은 '트랜잭션으로 묶는다'는 표현은 프로그래밍에서는 'AND'연산과 유사하다.

영속계층에서 withdraw()와 deposit()은 각각 데이터베이스와 연결을 맺고 처리하는데 하나의 트랜잭션으로 처리해야 할 경우에
는 한쪽이 잘못되는 경우에 이미 성공한 작업까지 다시 원상태로 복구되어야 한다. 별도의 패턴이나 프레임워크를 사용하지
않는 순수하게 JDBC를 이용하는 코드람녀 withdraw()와 deposit()의 내부는 아래와 같이 Connection을 맺고 처리하도록 작성될
것이다

public booleadn deposit(){
	Connection con = ....
	try{
		con = ...
	}catch(Execption e){
	}
	finally{
		try{con.close();}
	}
}
public booleadn withdraw(){
	Connection con = ....
	try{
		con = ...
	}catch(Execption e){
	}
	finally{
		try{con.close();}
	}
}
withdraw()와 deposit()이 위와 같이 고유하게 연결을 맺고 처리되는 구조라면 bankTransfer()를 작성할 때는 어느 한쪽이 실패할
때를 염두에 두고 코드를 복잡하게 만들어야 한다. 스프링은 이러한 트랜잭션 처리를 간단히 XML 설정을 이용하거나, 어노테이션
 처리만으로 할 수 있다.

데이터베이스 설계와 트랜잭션
데이터베이스의 저장 구조를 효율적으로 관리하기 위해서 흔히 '정규화'라는 작업을 한다. '정규화'의 가장 기본은 '중복된 데이터
를 제거'해서 데이터 저장의 효율을 올리자는 것이다. 정규화를 진행하면 1) 테이블은 늘어나고, 2) 각 테이블의 데이터 양은 줄어
드는 것이 일반적이다.

정규화를 진행하면서 원칙적으로 칼럼으로 처리되지 않는 데이터는 다음과 같다
*시간이 흐르면 변경되는 데이터를 칼럼으로 기록하지 않는다. - 데표적으로 사용자의 생년월일의 경우 칼럼에 기록하지만, 현재
나이는 칼럼으로 유지하지 않는다.(만일 나이에 대한 연산이 너무 빈번한 경우에는 칼럼으로 설정한 가능성도 있다)
*개선이 가능한 데이터를 칼럼으로 기록하지 않는다. - 주문과 주문 상세가 별도의 테이블로 분리되어 있다면 사용자가 한 번에
몇 개의 상품을 주문했는지 등을 칼럼으로 기록하지 않는다.(집합 연산이 성능에 영향을 주는 경우에만 칼럼으로 고려)
* 누구에게나 정해진 값을 이용하는 경우 데이터베이스에서 취급하지 않는다 - 예를 들어 2018년 1월 1일은 '월요일'이었고,이 
사실은 동일한 시간대를 사용하는 모든 사람들에게는 통용되기 때문에 데이터베이스에 기록하지 않는다.

정규화가 잘 되었거나, 위와 같은 규칙들이 반영된 데이터베이스의 설계에서는 '트랜잭션'이 많이 일어나지는 않는다. 정규화가 
진행될수록 테이블은 점점 더 순수한 형태가 되어가는데, 순수한 형태가 될수록 '트랜잭션 처리'의 대상에서 멀어진다. 정규화를
진행할수록 테이블은 더욱 간결해지지만 반대로 쿼리 등을 이용해서 필요한 데이터를 가져오는 입장에서는 점점 불편해 진다.
현재 상황을 알기 위해서는 단순히 조회를 하는 것이 아니라 직접 조인(join)이나 서브쿼리(subquery)를 이용해서 처리해야 하기
때문이다.

조인이나 서브쿼리를 이용하게 되면 다시 성능의 이슈가 발생할 수 있다. 매번 계산이 발생하도록 만들어지는 쿼리의 경우 성능
이 저하되기 때문에 많은 양의 데이터를 처리해야 하는 상황에서는 바람직하지 않을 수 있다. 이러한 상황에서는 흔히 '반정규화'
(역정규화)를 하게 된다. 정규화의 반대이므로 중복이나 계산되는 값을 데이터베이스 상에 보관하고, 대신에 조인이나 서브쿼리의
사용을 줄이는 방식이다.

반정규화의 가장 흔한 예가 '게시물의 댓글'의 경우이다. 정규화의 규칙을 따른다면 게시물 테이블과 댓글 테이블은 아래와 같은
구조를 가지는 것이 일반적이다.

BOOK_EX.TBL_BOARD				BOOK_EX.TBL_REPLY
P * BNO NUMBER(10)			  	P * RNO NUMBER(10)
   * TITLE VARCHAR2(200 BYTE)	            ↙	F * BNO NUMBER(10)
   * CONTENT VARCHAR2(2000 BYTE)    <-------	 -	  * REPLY VARCHAR2(1000 BYTE)
   * WIRITER VARCHAR2(50 BYTE)		↖	    REPLYDATE DATE
     REGDATE DATE					    UPDATEDATE DTAE			
     UPDATEDATE DATE
	
PK_BOARD(BNO)					PK_REPLY(RNO)
PK_BOARD(BNO)					FK_REPLY_BOARD(BNO)
						PK_REPLY(RNO)

정규화를 했다면 tbl_board 테이블에는 위와 같이 게시물에 대한 정보들만으로 칼럼이 구성되어야 하고, tbl_reply 테이블을 이용
해서 댓글들을 보관하게 된다. 문제는 게시물의 목록 페이지에서 일반적으로 댓글의 숫자도 같이 표시된다는 데 있다. 댓글을
추가한 뒤에 댓글의 숫자를 표시하려면 조인을 하거나 서브쿼리를 이용해서 처리하게 된다. 이러한 상황에서는 흔히 tbl_board
테이블에 댓글의 숫자를 칼럼으로 처리하는 경우가 많다. 댓글의 숫자를 칼럼으로 처리하게 되면 게시물의 목록을 가져올 경우
에는 tbl_reply 테이블을 이용해야 하는 일이 거의 없기 때문에 성능상으로 좀 더 이득을 볼 수 있게 된다.

반정규화는 이처럼 중복이나 계산의 결과를 미리 보관해서 좀 더 빠른 결과를 얻기 위한 노력이다. 반정규화를 하게 되면 쿼리가
단순해지고 성능상으로도 얻을 수 있는 이득이 있지만, 대신에 댓그링 추가될 때에는 댓글을 의미하는 tbl_reply 테이블에 insert
하고, 댓글의 숫자는 tbl_board테이블에 update를 시켜주는 작업이 필요하다. 두 작업은 하나의 트랜잭션으로 관리되어야 하는
작업이다.

PART6 파일 업로드 처리
대부분의 웹 프로젝트는 사용자가 첨부파일을 추가 할 수 있는 기능이 있다. 초기에는 단순히 <form>태그를 이용해서 첨부파일을 게시물 
작성과 같은 시점에 처리하는 방식을 사용했지만, 최근에는 첨부파일을 별도로 업로드해서 사용자가 최종적으로 게시물을 등록하기 전에
어떤 파일들을 업로드하는지 알 수 있는 방식을 사용한다.

첨부파일에 대한 처리는 흔히 업로드가 전부라고 생각하지만, 현실적으로 업로드된 이후에 처리가 상당히 복잡하다. 예를 들어 이미지 파일
의 경우네는 화면에 작은 섬네일 이미지를 생성해서 보여주어야 하고, 일반 파일의 경우에는 첨부파일이 존재한다는 아이콘만을 보여주어야 
한다. 또한 이미지의 경우는 대부분 클릭해서 원본 이미지를 확인 할 수 있게 하지만, 반면에 일반 파일의 경우에는 단순히 다운로드만을
처리해야 한다.

◆파일 업로드 방식

첨부파일을 서버에 전송하는 방식은 크게 <form> 태그를 이용해서 업로드하는 방식과 Ajax를 이용하는 방식으로 나눠볼 수 있다.

브라우저상에서 첨부파일에 대한 처리방법
⊙<form> 태그를 이용하는 방식: 브라우저의 제한이 없어야 하는 경우에 사용
-일반적으로 페이지 이동과 동시에 첨부파일을 업로드하는 방식
-<iframe>을 이용해서 화면의 이동없이 첨부파일을 처리하는 방식
⊙Ajax를 이용하는 방식: 첨부파일을 별도로 처리하는 방식
-<input type='file'>을 이용하고 Ajax로 처리하는 방식
-HTML5의 Drag And Drop 기능이나 jQurey 라이브러리를 이용해서 처리하는 방식

브라우저 상에서 첨부파일을 처리하는 방식은 다양하게 있지만, 서버 쪽에서의 처리는 거의 대부분 비스하다. 응답을 HTML 코드로 하는지
아니면 JSON 등으로 처리하느지 정도의 구분만 하면 된다. 

서버에서 주의해야 하는 점은 첨부파일의 처리를 위해서 어떤 종류의 라이브러리나 API등을 활용할 것인지에 대한 부분이다. 서버에서 첨부
파일을 처리하는 방식은 크게 다음과 같은 API들을 사용ㅎ나다.
⊙cos.jar: 2002년도 이후에 개바이 종료되었으므로, 더 이상 사용하는 것을 권장하지 않음
⊙commoms-fileupload: 가장 일반적으로 많이 활용되고, 서블릿 스펙 3.0 이전에도 사용 가능
⊙서블릿 3.0이상 - 3.0 이상부터는 자체적으로 파일 업로드 처리가 API상에서 지원

위의 방식에서 가장 일반적인 형태는 commons-fileupload를 이용한 설정이지만, Tomcat 7버전 이후에는 서블릿 3.0 이상을 지원하
므로, 이를 활용하는 방식으로 설정 사용. 첨부파일은 실제 서버가 동작하는 머신 내에 있는 폴더에 업로드 시켜야 하므로 C드라이브 밑에 
upload폴더와 임시 업로드 파일을 저장할 temp폴더를 생성.

첨부파일을 저장할 때 신경 쓰이는 것은 크게 두가지로 1) 중복된 이름의 파일 처리와 2) 한 폴더 내에 너무 많은 파일의 생성 문제이다.

1)의 경우는 현재 시간을 밀리세컨드(천분의 1초단위)까지 구분해서 파일 이름을 생성해서 저장하거나 UUOD를 이용해서 중복이 발생할 가능
성이 거의 없는 문자열을 생성해서 처리한다. 2)의 경우는 하나의 폴더에 생성될 수 있는 파일의 개수에 대한 문제인데, 한 폴더에 너무 많은
파일이 있는 경우 속도의 저하와 개수의 제한 문제가 생기는 것을 방지 해야 한다. 이에 대한 해결책으로 일반적인 방법은 '년/월/일'단위의
폴더를 생성해서 파일을 저장하는 것이다.

년/월/일 폴더의 생성
첨부파일을 보관하는 폴더를 생성하는 작업은 한 번에 폴더를 생성하거나 존재하는 폴더를 이용하는 방식을 사용한다. java.io.File에
존재하는 mkdirs()를 이용하면 필요한 상위 폴더까지 한 번에 생성할 수 있으므로 간단히 처리할 수 있다.

UploadController에 추가적인 메서드와 수정을 통해서 업로드 폴더 등을 처리한다.

◆섬네일 이미지 생성

이미지의 경로에 대한 처리와 중복 이름에 대한 처리가 완료되었다면, 남은 작업은 일반 파일과 이미지 파일을 구분하는 것이다. 이미지 파일
의 경우에는 화면에 보여지는 작은 이미지(이하 섬네일)를 생성하는 추가적인 처리이다. 만일 용량이 큰 파일을 섬네일 처리하지 않는다면
모바일과 같은 환경에서 많은 데이터를 소비해야만 하므로 이미지의 경우는 특별한 경우가 아니라면 섬네일을 제작해야만 한다.

섬네일을 제작한는 방법은 여러 가지 방식이 있다. JDK1.4 부터는 ImageIO를 제공하기 때문에 이를 이용해서 원본 이미지의 크기를 줄
일 수도 있고, ImagScalr와 같은 별도의 라이브러리를 이용하는 방식도 있다. JDK에 포함된 API를 이용하는 방식보다는 별도의 라이
브러리를 사용하는 경우가 많은데, 이는 이미지를 축소했을 때의 크기나 해상도를 직접 조절하는 작업을 줄이기 위해서이다.
Thumbnailator 라이브러리를 이용해서 섬네일 이미지를 생성한다.

UploadController에서는 다음과 같은 단계를 이용해서 섬네일을 생성한다.
-업로드된 파일이 이미지 종류의 파일인지 확인
-이미지 파일의 경우에는 섬네일 이미지 생성 및 저장

◆이미지 파일의 판단
화면에서 약간의 검사를 통해서 업로드 되는 파일의 확장자를 검사하기는 하지만, Ajax로 사용하는 호출은 반드시 브라우저만을 통해서 들어
오는 것이 아니므로 확인할 필요가 있다. 서버에 업로드된 파일은 조금 시간이 걸리더라도 파일 자체가 이미지인지를 정확히 체크한 뒤에 저장하
는 것이 좋다.

◆업로드된 파일의 데이터 반환
첨부파일 데이터의 업로드가 완료되었지만, 아직도 많은 작업이 남았다. Ajax를 이용해서 파일을 업로드했지만, 아직 브라우저 쪽에 아무런
데이터도 전달하지 않았기 때문에 브라우저에서는 어떠한 피드백도 받을 수 없는 상황이다. 서버에서 Ajax의 결과로 전달해야 하는 데이터는
업로드된 파일의 경로가 포함된 파일의 이름이다. 섬네일의 경우에는 's_'로 시작한다는 규칙만 알고 있으면 필요할 때 사용할 수 있다.

브라우저로 전송해야 하는 데이터는 다음과 같은 정보를 포함하도록 설계해야 한다.
-업로드된 파일의 이름과 원본 파일의 이름
-파일이 저장된 경로
-업로드된 파일이 이미지인지 아닌지에 대한 정보

이에 대한 모든 정보를 처리하는 방법은 1)업로드된 경로가 포함된 파일 이름을 반환하는 방식과 2) 별도의 객체를 생성해서 처리하는 방법을 고
려할 수 있다. 1)의 경우에는 브라우저 쪽에서 해야 하는 일이 많기 때문에 2)의 방식으로 구성하도록 한다.

◆브라우저에서 섬네일 처리
브라우저에서 첨부파일의 업로드 결과가 JSON 객체로 반환되었다면, 남은 작업은 당ㅁ과 같다.
-업로드 후에 업로드 부분을 초기화 시키는 작업
-결과 데이터를 이용해서 섬네일이나 파일 이미지를 보여주는 작업

현재 업로드는 <input type='file'>을 통해서 이루어지기 때문에 한 번 업로드가 끝난 후에는 이를 초기화 시켜주는 작업과 업로드된 결과를 
화면에 반영해 줄 필요가 있다.

◆<input type='file'>의 초기화
<input type='file'>은 다른 DOM 요소들과 조금 다르게 readonly라 안쪽의 내용을 수정할 수 없기 때문에 별도의 방법으로 초기화 시
켜서 또 다른 첨부파일을 추가할 수 있도록 만들어야한다.

우선 첨부파일을 업로드하기 전에 아무 내용이 없는 <input type='file'> 객체가 포함된 <div>를 복사(clone)한다. 첨부파일을 업
로드한 뒤에는 복사된 객체를 <div> 내에 다시 추가해서 첨부파일 부분을 초기화시킨다.


◆첨부파일의 다운로드 혹은 원본 보여주기
첨부파일의 업로드가 처리되는 과정도 복잡하지만, 이를 사용자가 사용하는 과정 역시 신경써야 하는 일이 많다. 브라우제에서 보이는 첨부파일은
크게 1)이미지 종류와 2)일반 파일로 구분되므로 사용자의 첨부파일과 관련된 행위도 종류에 따라 다르게 처리되어야 한다. 

만일 첨부파일이 이미지인 경우에는 섬네일 이미지를 클릭했을 때 화면에 크게 원본 파일을 보여주는 형태로 처리되어야 한다.이 경우는 브라우저에서
새로운 <div> 등을 생성해서 처리하는 방식을 이용하는데 흔히 'light-box'라고 한다. 'light-box'는 jQurey를 이용하는 많은 플
러그인들이 있으므로, 이를 이용하거나 직접 구현할 수 있다. 

첨부파일이 이미지가 아닌 경우에는 기본은 다운로드이다. 사용자가 파일을 선택하면 다운로드가 실행되면서 해당 파일의 이름으로 다운로드가 가능
해야 한다.

◆첨부파일의 다운로드
이미지를 처리하기 전에 우선 좀 더 간단한 첨부파일의 다운로드부터 처리하도록 한다. 첨부파일의 다운로드는 서버에서 MIME 타입을 다운로드 타
입으로 지정하고, 적절한 헤더 메시지를 통해서 다운로드 이름을 처리한다. 이미지와 달리 다운로드는 MIME 타입이 고정되기 때문에 메서드는 아래
와 같이 시작하게 된다.
@GetMapping(value="/download", produces=MediaType.APPLIACTION_OCTET_STREAM_VALUE)
@ResponseBody
public ResponseEntity<Resource> downloadFile(String fileName){
	log.info("download file: "+ fileName);
	
	Resource resource = new FileSystemResource("c:\\upload\\"+fileName);
	
	log.info("resource: + resource);
	
	return null;
}


ResponseEntity<>의 타입은 byte[] 등을 사용할 수 있으나, 이번 예제에서는 org.springframework.core.io.Resource타입
을 이용해서 좀 더 간단히 처리하도록 한다.

MIME타입은 다운로드를 할 수 있는 'application/octet-stream'으로 지정하고, 다운로드 시 저장되는 이름은 'Content-Disposition'
을 이용해서 지정한다. 파일 이름에 대한 문자열 처리는 파일 이름이 한글인 경우 저장할 때 깨지는 문제를 막기 위해서 이다. 크롬 브라우저에서 C:\upload
폴더에 있는 파일의 확장자로 '/download?fileName=xxxx'와 같이 호출하면 브라우저는 자동으로 해당 파일을 다운로드하는 것을 볼 수 있다. IE계
열에서는 파일 다운로드가 호출이 안되는 문제가 발생한다.


◆IE/Edge 브라우저의 문제
첨부파일의 다운로드 시 Chrome 브라우저와 달리 IE에서는 한글 이름이 제대로 다운로드 되지 않는다. 이것은 'Content-Disposition'의 값을 처리
하는 방식이 IE의 경우 인코딩 방식이 다르기 때문이다. 

IE를 같이 서비스해야 한다면 HttpServletRequest에 포함된 헤더 정보들을 이용해서 요청이 발생한 브라우저가 IE계열인지 확인해서 다르게 처리하는 방
식으로 처리한다. HTTP 헤더 메세지 중에서 디바이스의 정보를 알 수 있는 헤더는 'User-Agen'값을 이용한다.(이를 이용해서 브라우저의 종류나 모바일인지
데스크톱인지 혹은 브라우저의 프로그램의 종류를 구분할 수 있다.)

기존의 downloadFile()은 'User-Agen'정보를 파라미터로 수집하고, IE에 대한 처리를 추가한다. Edge브라우저는 IE와 또 다르게 처리되므로 주의
 

◆원본 이미지 보여주기
일반 첨부파일과 달리 섬네일이 보여지는 이미지 파일의 경우 섬네일을 클릭하면 원본 이미지를 볼 수 있게 처리합니다. 
섬네일의 이미지가 '업로드된 경로 +/s_+UUID_+파일이름' 이었다면, 원본 이미지의 이름은 중간에 '/s_'가 '/'로 변경되는 점이 다르다. 
원본 이미지를 화면에 보기 위해서는 <div>를 생성하고, 해당 <div>에 이미지 태그를 작성해서 넣어주는 작업과 이를 화면상에서 절대 위치를 이용해서 보여줄
필요가 있다.

◆원본 이미지를 보여줄 <div>처리
이미지의 경우 일반 파일과 달리 이미 이미지 파일 데이터는 섬네일과 동일한 방식으로 처리될 수 있기 때문에 사실상 핵심적인 부분은 이미지를 보여주는 <div>를
처리하는 부분이 핵심이다.

<div>를 처리하는 부분은 섬네일 파일을 클릭할 때 이루어 지도록 JavaScript 함수를 작성한다.

원본 이미지 혹은 주변 배경을 선택하면 우선은 이미지를 화면 중앙으로 작게 점차 줄여준다(1초동안), jQuery의 애니메이션이 끝난 후 이벤트를 감지하는 방식
도 있지만, 예제는 1초 후에 자동으로 배경창을 안 보이도록 처리하는 방식을 이용한다.

setTimeout()에 적용된 '=>(ES6의 화살표 함수)'는 Chrome에서는 정상 작동하지만, IE 11에서는 제대로 동작하지 않으므로 필요하다면 변경해서 
사용한다.

◆첨부파일 삭제
첨부파일 삭제는 생각보다 많은 고민이 필요한 작업이다. 단순히 파일 하나만을 삭제한다고 생각할 수 있지만 실제로는 다음과 같은 문제점들을 고민해야 한다.
-이미지 파일의 경우에는 섬네일까지 같이 삭제되어야 하는 점
-파일을 삭제한 후에는 브라우저에서도 섬네일이나 파일 아이콘이 삭제되도록 처리하는 점
-비정상적으로 브라우저의 종료 시 업로드된 파일의 처리

◆일반 파일과 이미지 파일의 삭제
업로드된 첨부파일의 삭제는 Ajax를 이용하거나 <form> 태그를 이용하는 방식 모두를 적용할 수 있다. 이미 업로드된 첨부파일의 삭제는 일반 파일의 경우에는
업로드된 파일만 삭제하면 되지만, 이미지의 경우 생성된 섬네일 파일과 원본 파일을 같이 삭제해야 한다.

서버 측에서는 삭제하려는 파일의 확장자를 검사해서 일반 파일인지 이미지 파일인지를 파악하거나 파라미터로 파일의 종류를 파악하고, 이를 이용하여 처리를 다르게
한다.

◆첨부파일의 삭제 고민
첨부파일을 삭제하는 작업의 최대 고민은 사용자가 비정상적으로 브라우저를 종료하고 나가는 행위이다. 서버에는 Ajax를 이용해서 업로드 했기 때문에 이미 저장이 
된 상태지만, 사용자가 '작업관리자'나 전원 버튼을 누르는 등의 조치를 해서 브라우저 자체를 종료해 버린다면 이를 감지할 수 있는 적당한 방법이 없다.(브라우저의
창이 닫히는 이벤트는 가능하긴 하지만 비정상적인 종료는 문제가 된다)

이에 대한 가장 좋은 해결책은 실제 최종적인 결과와  서버에 업로드된 파일의 목록을 비교해서 처리하는 것이다. 보통 이런 작업은 spring-batch나 Quartz
라이브러리를 이용해서 처리한다.

◆프로젝트의 첨부파일-등록
첨부파일을 어떤 방식으로 처리하는지에 대한 학습이 완료되었다면 기존의 프로젝트에 첨부파일 기능을 추가하는 작업을 진행한다. 첨부파일은 게시물의 등록/조회/
수정/,삭제 화면에서 처리할 필요가 있으므로 각 단계마다 나누어서 개발을 진행한다. 개발을 위해서 현재 예제를 작성한 프로젝트에 기존 프로젝트의 설정이나 패키
지등을 먼저 복사해서 추가한 상태로 개발을 시작한다.

◆첨부파일 정보를 위한 준비
첨부파일이 게시물과 합쳐지면 가장 먼저 진행해야 하는 일은 게시물과 첨부파일의 관계를 저장하는 테이블의 설계가 우선이다. 게시물의 첨부파일은 각자 고유한
UUID를 가지고 있기 때문에 별도의 PK를 지정할 필요는 없지만, 게시물을 등록할 때 첨부파일 테이블 역시 같이 insert 작업이 진행되어야 하므로 트랜잭션
처리가 필요하다.

첨부파일을 보관하는 테이블은 tbl_attach로 설계한다. tbl_board는 tbl_reply와 이미 외래키의 관계를 가지고 있으므로 첨부파일이 추가되면 아래와
같은 구조가 된다.
create table tbl_attach(
	uuid varchar2(100) not null,
	uploadPath varchar2(200) not null,
	fileName varchar2(100) not null,
	filetype char(1) default 'I',
	bno number(10,0)
);

alter table tbl_attach add constraint pk_attach primary key(uuid);

alter table tbl_attach add constraint fk_board_attach foreign key(bno) references tbl_board(bno);

첨부파일의 보관은 UUID가 포함된 이름을 PK로 하는 uuid칼럼과 실제 파일 업로드된 경로를 의미하는 uploadPath, 파일 이름을 의미하는 fileName,이미
지 파일 여부를 판단할 수 있는 fileType, 해당 게시물 번호를 저장하는 bno 칼럼을 이용한다.

SQL을 처리하기 위해서는 파일 정보를 처리하기 위해 파라미터를 여러 개 사용해야 하는 불편함이 있으므로, org.zerock.domain 패키지에 아에 BoardAttachVO
클래스를 설계하는 것이 유용하다(AttachFileDTO와 거의 유사하지만 게시물의 번호가 추가되었고, 혼란을 피하기 위해서 새로운 클래스를 작성).

◆등록을 위한 화면 처리
첨부파일 자체의 처리는 Ajax를 통해서 이루어지므로, 게시물의 등록 시점에는 현재 서버에 업로드된 파일들에 정보를 등록하려는 게시물의 정보와 같이 전송해서
처리한다. 이 작업은 게시물의 등록 버튼을 클릭했을 때 현재 서버에 업로드된 파일의 정보를 <input type='hidden'>으로 만들어서 한번에 전송하는 방식을
사용한다.

◆게시물 등록과 첨부파일의 데이터베이스 처리
게시물의 등록 과정에서는 첨부파일의 상세 조회는 의미가 없고, 단순히 새로운 첨부파일을 추가하거나 삭제해서 자신이 원하는 파일을 게시물 등록할 때 같이 포함하도록
한다. Ajax를 이용하는 경우 이미 어떠한 파일을 첨부로 처리할 것인지는 이미 완료된 상태이므로 남은 작업은 게시물이 등록될 때 첨부파일과 관련된 자료를 같이 전송하고
이를 데이터베이스에 등록하는 것이다. 게시물의 등록은 <form> 태그를 통해서 이루어지므로, 이미 업로드된 첨부파일의 정보는 별도의 <input type='hidden'>
태그를 생성해서 처리한다.

이를 위해서 첨부파일 정보를 태그로 생성할 때 첨부파일과 관련된 정보(data-uuid, data-fileName, data-type)를 추가한다.

BoardVO에는 attachList라는 이름의 변수로 첨부파일의 정보를 수집하기 때문에 <input type='hidden'>의 name은 'attachList[인덱스번호]'와 같은
이름을 사용하도록 한다.

◆게시물의 조회와 첨부파일
게시물의 조회에서는 첨부파일을 다운로드하거나 원본 이미지의 파일을 볼 수 있는 기능을 사용하게 된다. 게시물의 조회에서 고민해야 하는 내용은 첨부파일을 한 번에 볼 것
인지, Ajax를 이용해서 별도로 처리할 것인지에 대한 결정이다.

게시물의 정보는 tbl_board 테이블에 기록되어 있고, 첨부파일의 정보는 tbl_attach에 기록되어 있기 때문에 화면에서 두 테이블에 있는 정보를 사용하기 위해서는
다음과 같은 방식을 고려
-BoardVO 객체를 가져올 때 join을 처리해서 한꺼번에 게시물과 첨부파일의 정보를 같이 처리하는 방식. 데이터베이스를 한 번만 호출하게 되므로 효율적이지만 MyBatis
쪽에서 처리해야 하는 일이 많아진다.
-JSP에서 첨부파일의 정보를 Ajax를 이용해서 처리하는 방식이다.다시 쿼리를 처리해야 하는 불편함이 있지만 난이도가 낮고, 화면에서 처리는 JavaScript가 복잡함

위의 방식들 중에서 전통적인 방식은 쿼리를 이용해서 두 개의 테이블을 join해서 처리하는 방식이다. 쿼리를 한 번만 실행하기 때문에 데이터베이스의 부하를 줄여줄 수 있
다는 장점이 있다. join을 이용해서 하나의 객체를 구성하는 방식은 조금 뒤쪽에서 알아본다.

◆게시물의 삭제와 첨부파일

BoardController는 데이터베이스의 삭제를 먼저 호출하고, 이후 파일을 삭제해야 한다. 다만 파일을 삭제하기 위해서는 해당 게시물의 첨부파일 목록이 필요하다.
문제는 첨부파일의 목록을 구한다고 해도 이미지 파일의 경우에는 섬네일 파일이 생성되어 있으므로 이에 대한 처리가 필요하다는 점이다.
-해당 게시물의 첨부파일 정보를 미리 준비
-데이터베이스 상에서 해당 게시물과 첨부파일 데이터 삭제
-첨부파일 목록을 이용해서 해당 폴더에서 섬네일 이미지(이미지 파일의 경우)와 일반 파일을 삭제


◆게시물의 수정과 첨부파일

게시물을 수정할 때 첨부파일과 관련된 작업은 사실상 게시물 등록 작업과 상당히 유사하다. 첨부파일이라는 개념 자체가 수정이 아닌 기존 파일을 삭제하고, 새로운 파일을 추가
하기 때문이다. 게시물 수정에서 첨부파일은 수정이라는 개념보다는 삭제 후 다시 추가한다는 개념으로 접근해야 한다. 게시물의 수정에는 기존의 게시물 테이블을 수정하는 
작업과 변경(새롭게 추가된)된 첨부파일을 등록하는 작업으로 이루어진다.

◆화면에서 첨부파일수정
수정은 views 폴더 내에 /board/modify.jsp에서 이루어진다. 게시물의 수정은 게시물의 조회화면과 유사하지만 1)원본 이미지 확대나 다운로드 기능이 필요하지 
않다는 점, 2)게시물 조회와 달리 삭제 버튼이 있어야 하는 점이 다르다.

◆잘못된 업로드된 파일 삭제
Ajax를 이용해서 첨부파일을 사용하면 사용자가 게시물을 등록하거나 수정하기 전에 미리 업로드시킨 파일들을 볼 수 있다는 장점이 있지만, 다음과 같은 문제발생
-첨부파일만을 등록하고 게시물을 등록하지 않았을 때의 문제 -파일은 이미 서버에 업로드되었지만, 게시물을 등록하지 않았으므로 의미 없이 파일들만 서버에 업로드된 상황
-게시물을 수정할 때 파일을 삭제했지만 실제로 폴더에서 실제로 폴더에서 기존 파일은 삭제 되지 않은 문제 -데이터베이스에서는 기존 파일이 삭제되었지만, 실제 폴더에는
남는 문제

위 상황의 공통적인 문제는 사용자가 Ajax로 어떤 작업을 한 후에 비정상적으로 브라우저를 종료하거나 페이지를 빠저나가는 문제이다. 이 문제를 해결하는 핵심은 정상적으로
사용자의 게시물에 첨부된 파일인지 아니면 사용자가 게시물을 수정할 때 업로드했지만 최종적으로 사용되는 파일인지 아닌지를 파악하는 것이 핵심

◆잘못 업로드된 파일의 정리
게시물에 필요한 모든 파일에 대한 정보는 최종적으로는 데이터베이스에 기록되어 있다. 만일 사용자가 게시물을 등록하거나 수정하기 위해서 첨부파일을 등록했지만. 최종적
으로  submit을 하지 않은 경우에는 폴더에 파일들은 업로드되지만, 데이터베이스에는 아무 변화 없게 된다.

만일 정상적으로 해당 첨부파일이 게시물에 사용된다면 데이터베이스의 tbl_attach 테이블에 기록되어 있을 것이므로 데이터베이스와 비교하는 작업을 거쳐서 업로드만 된 
파일의 목록을 찾아야 한다.

◆Quartz 라이브러리 설정
Quartz 라이브러리는 일반적으로 스케줄러를 구성하기 위해서 사용한다. 서버를 운영하기 위해서는 간혹 주기적으로 매일, 매주, 매월 등 주기적으로 특저한 프로그램을
실행할 필요가 있다. 이 작업은 운영체제의 기능을 이용해서 작업할 수도 있지만, 스프링과 Quartz라이브러리를 이용하면 간단히 처리할 수 있다.



◆Spring Web Security를 이용한 로그인 처리
거의 대부분 웹 기반의 프로젝트에서는 사용자의 권한이나 등급에 기반을 두는 로그인 체크를 이용한다. 웹에서는 기본적으로 쿠키를 이용하거나 세션을 이용하는 방식이 일반적
이다. 스프링에서도 이를 활용할 수 있는 방법은 Interceptor 등을 이용해서 처리할 수 있다.

◆Spring Web Security 소개
스프링 시큐리티의 기본 동작 방식은 서블릿의 여러 종류의 필터와 인터셉터를 이용해서 처리된다. 필터는 서블릿에서 말하는 단순한 필터를 의미하고, 인터셉터는 스프링에서
필터와 유사한 역할을 한다.

필터와 인터셉터는 특정한 서블릿이나 컨트롤러의 접근에 관여한다는 점에서 유사하지만 결정적인 차이를 구분하자면 필터는 스프링과 무관하게 서블릿 자원이고, 인터셉터는 
스프링의 빈으로 관리되면서 스프링의 컨텍스트 내에 속한다는 차이이다.

스프링 시큐리티는 현재 동작하는 스프링 컨텍스트 내에서 동작하기 때문에 이미 컨텍스트에 포함된 여러 빈들을 같이 이용해서 다양한 방식의 인증 처리가 가능하도록 설계할
수 있다.

●정리
1.스프링 시큐리티란?
스프링 시큐리티는 스프링 기반의 어플리케이션의 보안(인증과권한)을 담당하는 프레임워크이다. 만약 스프링시큐리티를 사용하지 않았다면, 자체적으로 세션을 체크하고
redirect등을 해야할 것이다. 스프링 시큐리티는 보안과 관련해서 체계적으로 많은 옵션들로 이를 지원해 준다. spring security는 filter 기반으로 동작하기
때문에 spring MVC와 분리되어 관리 및 동작한다. 
용어정리
-접근 주체(Principal) : 보호된 대상에 접근하는 유저
-인증(Authenticate) : 현재 유저가 누구인지 확인(ex.로그인) = 애플리케이션의 작업을 수행할 수 있는 주체임을 증명
-인가(Authorize) : 현재 유저가 어떤 서비스, 페이지에 접근할 수 있는 권한이 있는지 검사
-권한: 인증된 주체가 애플리케이션의 동작을 수행할 수 있도록 허락되있는지를 결정
	= 권한 승인이 필요한 부분으로 접근하려면 인증 과정을 통해 주체가 증명 되어야만 한다.
	= 권한 부여에도 두가지 영역이 존재하는데 웹 요청 권한, 메소드 호출 및 도메인 인스턴스에 대한 접근 권한 부여

2.spring security의 구조
spring security는 세션-쿠키방식으로 인증한다.
여기서는 전통적인 쿠키-세션 방식을 사용한다.

1)유저가 로그인을 시도(http request)
2)AuthenticationFilter에서부터 user DB까지 타고 들어감
3)DB에 있는 유저라면 UserDetails로 꺼내서 유저의 session 생성
4)spring security의 인메모리 세션저장소인 SecurityContextHolder에 저장
5)유저에게 sessionID와 함께 응답을 내려줌
6)이후 요청에서는 요청쿠키에서 JSESSIONID를 까봐서 검증 후 유효하면 Authentication(인증)를 쥐어준다.

security의 filter들
1.SecurityContextPersistenceFilter : SecurityContextRepository에서 SecurityContext
를 가져 오거나 저장하는 역할을 한다.
2.LogoutFilter: 설정된 로그아웃 URL로 오는 요청을 감시하며, 해당 유저를 로그아웃 처리
3.(UsernamePassword)AuthenticationFilter:(아이디와 비밀번호를 사용하는 form 기반 인증) 설정된 로그인
URL로 오는 요청을 감시하며, 유저 인증 처리
	1)AuthenticationManager를 통한 인증 실행
	2)인증 성공 시, 얻은 Authentication 객체를 SecurityContext에 저장후 
	AuthenticationSuccessHandler 실행
	3)인증 실패 시, AuthenticationFailureHandler 실행
4.DefaultLoginPageGenerationgFilter: 인증을 위한 로그인폼 URL을 감시한다.
5.BasicAuthenticationFilter: HTTP 기본 인증 헤더를 감시하여 처리한다.
6.RequestCacheAwareFilter : 로그인 성공 후, 원래 요청 정보를 재구성하기 위해 사용된다.
7.SecurityContextHolderAwareRequestFilter: HttpServletRequestWrapper를 상속한
SecurityContextHolderAwareRequestWrapper 클래스는 필터 체인상의 다음 필터들에게 부가정보를 제공한다
8.AnonymousAuthenticationFilter: 이 필터가 호출되는 시점까지 사용자 정보가 인증되지 않았다면 인증토큰에 사용자
가 익명 사용자로 나타난다.
9.SessionManagementFilter: 이 필터는 인증된 사용자와 관련된 모든 세션을 추적한다.
10.ExceptionTranslationFilter: 이 필터는 보호된 요청을 처리하는 중에 발생할 수 있는 예외를 위임하거나 전달하는
역할을 한다.
11.FilterSecurityInterceptor: 이 필터는 AccessDecisionManager로 권한부여 처리를 위임함으로써 접근
제어 결정을 쉽게해준다.

Authentication
모든 접근 주체(=유저)는 Authentication를 생성한다. 이것은 SecurityContext에 보관되고 사용된다.
즉 security의 세션들은 내부 메모리에 쌓고 꺼내 쓰는 것이다. 
public interface Authentication extends Principal, Serializable{
	Collection<? extends GrantedAuthority> getAuthorities();	//Authentication 저장소에 의해 인증된 사용자의 권한
	Object getCredentials();	//주로 비밀번호
	Object getDetails();	//사용자 상세정보
	Object getPrincipal();	//주로 ID
	boolean isAuthenticated();	//인증 여부
	void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
}

유저의 요청내에 담긴 Authentication를 AuthenticationManager에 넘겨주고,
AuthenticationManager를 구현한 ProviderManager가 처리한다. 정확히는 ProviderManager는 
private List<AuthenticationProvider> providers;로 여러 AuthenticationProvider를 가질 수 있는데, 이 친구들이 처리
해서 Authentication를 반환해준다

◆Spring Web Security의 설정
스프링 시큐리티는 스프링의 여러 하위 프로젝트 중에 하나이므로,https://projects.spring.io/spring-security/와 같은 페이지를 이용해서 필요한 버전을
추가한다.

◆security-context.xml생성
스프링 시큐리티는 단독으로 설정할 수 있기 때문에 기존의 root-context.xml이나 servlet-context.xml과 별도로 따로 작성하는 것이 좋다.
security-context.xml 파일은 메뉴에서 'Spring Bean Configuration File'메뉴를 통해서 생성하거나 일반 XML파일로 생성할 수 있다.

◆시큐리티가 필요한 URI 설계
스프링 시큐리티의 최소한의 설정이 완료되었다면 시큐리티에 의해 제어가 필요한 URI를 설계하고 적용하도록 한다. 
-/sample/all -> 로그인 하지 않은 사용자도 접근 가능한 URI
-/sample/member -> 로그인 한 사용자들만이 접근할 수 있는 URI
-/sample/admin -> 로그인 한 사용자들 중에서 관리자 권한을 가진 사용자만 접근할 수 있는 URI

◆인증(Authentication)과 권한 부여(Authorization-인가)
스프링 시큐리티의 동작을 이해하기 위해서는 가장 중요한 용어인 인증과 권한에 대한 이해이다. 인증과 권한에 대한 두 단어의 의미에 대해 정리.

'인증'은 쉽게 말해서 '자신을 증명하는 것'이다. 다시 말해서 자기 스스로가 무언가 자신을 증명할 만한 자료를 제시하는 것이다. 반면에 '권한 부여'는  남에 의해서 자격이
부여된다는 점에서 차이가 있다.

예시로 엔지니어 A는 B회사에 고장 난 데이터베이스를 고치기 위해 방문한다. 예약을 한 상태에서 방문한 A씨는 우선 회사 입구에서 '본인을 인증'할 것을 요구받는다. 출입증
을 검사하는 직원은 A의 신분은 확인한다. 인증이란 이처럼 본인이 무엇인가를 증명하는 행위라고 보면 된다.

회사 내부에 들어간 A씨는 다시 담당자를 만나서 데이터베이스의 접근 권한 등의 정보를 얻어야 한다. 이 과정을 인가 혹은 권한 부여라고 볼 수 있다. 권한 부여 과정에서 A씨에는
 데이터베이스를 조회하거나 수정할 수 있는 권한이 부여된다.
 스프링 시큐리티의 내부에도 이와 비슷한 구조를 가지고 있다. 스프링 시큐리티에서 가장 중요한 역할을 하는 존재가 인증을 담당하는 AuthenticationManager(인증매니저)
 라는 존재이다. AuthenticationManager는 다양한 방식의 인증을 처리할 수 있도록 아래와 같은 구조로 설계
 
 			AuthenticationManager
 					↑
 				ProviderManager
 					↑
 	DaoAuthenticationProvider,CasAuthenticationProvider,RemoteAuthenticationProvider,LdapAuthenticationProvider
 
ProviderManager는 인증에 대한 처리를 AuthenticationProvider라는 객체를 이용해서 처리를 위임한다.

AuthenticationManager
		↑
	ProviderManager	↔ AuthenticationProvider
	
AuthenticationProvider(인증 제공자)는 실제 인증 작업을 진행한다. 이때 인증된 정보에는 권한에 대한 정보를 같이 전달하게 되는데 이 처리는 
UserDetailsService라는 존재와 관련이 있다. UserDetailsService 인터페이스의 구현체는 실제로 사용자의 정보와 사용자가 가진 권한의 정보를 처리해서 반환한다.

개발자가 스프링 시큐리티를 커스터마이징 하는 방식은 크게 AuthenticationProvider를 직접 구현하는 방식과 실제 처리를 담당하는 UserDetailsService를 구현하는 
방식으로 나누어진다. 대부분의 경우에는 UserDetailsService를 구현하는 형태를 사용하는 것으로도 충분하지만, 새로운 프로토콜이나 인증 구현 방식을 직접 구현하는 경우
에는 AuthenticationProvider 인터페이스를 직접 구현해서 사용한다.

◆로그아웃 확인
스프링 시큐리티를 학습하다 보면 매번 로그아웃하고 새롭게 로그인을 해야 하는 상황이 자주 발생한다. 이에 대해서 가장 확실한 방법은 브라우저에서 유지하고 있는 세션과 관련된
정보를 삭제하는 것이다. 개발자 도구에서 Application 탭을 확인해 보면 'Cookie'항목에 'JSESSIONID'와 같이 세션을 유지하는데 사용되는 세션 쿠키의 존재를 확인
할 수 있다. (JSESSION은 Tomcat에서 발행하는 쿠키의 이름이다)

로그아웃은 JSESSION 쿠키를 강제로 삭제해서 처리한다.

◆여러 권한을 가지는 사용자 설정
정상적으로 로그인이 처리되는 것을 확인했다면 '/sample/admin'을 처리하도록 한다. '/sample/admin'은 'ROLE_ADMIN'이라는 권한을 가진 사용자가 접근할 수 있도록
지정하는데 사용자는 'ROLE_ADMIN'과 'ROLE_MEMBER'라는 2개의 권한을 가지도록 지정한다.

◆접근 제한 메시지의 처리
특정한 사용자가 로그인은 했지만, URI를 접근할 수 있는 권한이 없는 상황이 발생할 수도 있다. 이 경우에는 접근 제한 에러 메시지를  보게 된다.
HTTP Status 403 – Forbidden

스프링 시큐리티에서는 접근 제한에 대해서 AccessDeniedHandler를 직접 구현하거나 특정 URI를 지정할 수 있다.

Access Denied의 경우 403 에러 메세지가 발생한다. JSP에서는 HttpServlet Request 안에 'SPRING_SECURITY_403_EXCEPTION'이라는 이름으로 
Access DeniedExpression 객체가 전달된다. 브라우저에서 '/sample/admin' URI를 member/member 정보로 로그인한 사용자가 접근하는 경우 이전과
달리 에러 메세지 대신에 accessError.jsp의 내용이 보이게 된다.

◆AccessDeniedHandler 인터페이스를 구현하는 경우
<security:'access-denied-handler error-page="/accessError" />와 같이 error-page만을 제공하는 경우에는 사용자가 접근했던 URI 자체의
변화는 없다. URI 자체는 '/sample/admin'으로 되어있고, 화면의 내용은 '/accessError'에 해당하는 URI의 결과이다.

접근 제한이 된 경우에 다양한 처리를 하고 싶다면 직접 AccessDeniedHandler 인터페이스를 구현하는 편이 좋다. 예를 들어 접근 제한이 되었을 때 쿠키나 세션에 대한 특정한
작업을 하거나 HttpServletResponse에 특정한 헤더 정보를 추가하는 등의 행위를 할 경우에는 직접 구현하는 방식이 더 권장.

◆커스텀 로그인 페이지
스프링 시큐리티에서 기본적으로 로그인 페이지를 제공하기는 하지만, 현실적으로 화면 디자인 등의 문제로 사용하기 불편하다. 때문에 거의 대부분 경우 별도의 URI를 이용해서 로그인
페이지를 다시 제작해서 사용한다. 이를 이용하는 방식은 접근 제한 페이지와 유사하게 직접 특정한 URI를 지정할 수 있다.

◆CSRF(Cross-site request forgery) 공격과 토큰
스프링 시큐리티에서 POST방식을 이용하는 경우 기본적으로 CSRF 토큰이라는 것을 이용하게 된다. 별도의 설정이 없다면 스프링 시큐리티가 적용된 사이트의 모든 POST방식에는 
CSRF 토큰이 사용되는데 '사이트간 위조 방지'를 목적으로 특정한 값을 토큰을 사용하는 방식이다.

CSRF 공격은 '사이트간 요청 위조'라고 번역될 수 있다. 서버에서 받아들이는 정보가 특별히 사전 조건을 검증하지 않는다는 단점을 이용하여 공격하는 방식이다. 실제로 2008년
국내 인터넷 A 쇼핑몰이 이 기법으로 관리자 계정을 탈취해서 개인정보들이 유출되었다. CSRF를 이용해서 단순히 게시물의 조회수를 늘리는 등의 조작부터 피해자들의 계정을 이용
하는 다양한 공겨이 가능하다.

예를 들어 인터넷에 A라는 사이트가 존재한다고 가정한다. A 사이트에는 특정 사용자의 등급을 변경하는 URI가 존재하는 것을 공격자가 알았고, 해당 URI에는 약간의 파라미터가 
필요하다는 것을 알아챘다고 가정한다.

www.aaa.xxx/update?grade=admin&account=123

공격자는 A 사이트의 관리자(피해자)가 자주 방문하는 B사이트에 <img>태그나 <form>태그를 이용해서 위의 URI를 추가한 게시물을 작성한다.
A 사이트의 관리자(피해자)는 자신이 평상시에 방문하던 B사이트를 방문하게 되고 서버에서는 로그인한 관리자의 요청에 의해서 공격자는 admin등급의 사용자로 변경된다

A사이트의 관리자(피해자)는 자신이 관리하던 A사이트에 로그인이 되어 있는 상태라면 A사이트의 서버 입장에서는 로그인한 사용자의 정상적인 요청으로 해석된다. CSRF공격은
서버에서 받아들이는 요청을 해석하고 처리할 때 어떤 출처에서 진행되었는지 따지지 않기 때문에 허점을 노리고 공격하는 방식이다. '사이트간 요청 위조'라고 하지만 현실적으로는
하나의 사이트 내에서도 가능하다. CSRF는 <img> 태그 등의 URI 등을 이용할 수 있기 때문에 손쉽게 공격할 수 있는 방법이다.

CSRF 공격을 막기 위해서는 여러 방식이 존재할 수 있다. CSRF 공격 자체가 사용자의 요청에 출처를 검사하지 않아서 생기는 허점이기 때문에 사용자의 요청에 대한 출처를
의미하는 referer 헤더를 체크하거나 일반적인 경우에 잘 사용되고 있지 않고 REST방식에서 사용하는 PUT,DELETE와 같은 방식을 이용하는 등의 방식을 고려해 볼 수 있다.

◆CSRF 토큰
CSRF 토큰은 사용자가 임의로 변하는 특정한 토큰값을 서버에서 체크하는 방식이다.서버에는 브라우저에 데이터를 전송할 때 CSRF 토큰을 같이 전송한다. 사용자가 POST방식
등으로 특정한 작업을 할 때는 브라우저에서 전송된 CSRF토큰의 값과 서버가 보관하고 있는 토큰의 값을 비교한다. 만일 CSRF 토큰의 값이 다르다면 작업을 처리하지 않는 방식

서버에서 생성하는 토큰은 일반적으로 난수를 생성해서 공격자가 패터을 찾을 수 없도록 한다. 사용자가 '/customLogin'을 처음 호출했을 때와 강제로 세션 쿠키를 삭제한 후
다시 호출했을 때 CSRF 토큰의 값이 변경된 겂을 확인한다.

customLogin.jsp에서 CSRF토큰을 지정
<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" /> 

공격자의 입장에서는 CSRF 공격을 하려면 변경되는 CSRF토큰의 값을 알아야만 하기 때문에 고정된 내용의 <form> 태그나 <img>태그 등을 이용할 수 없게 된다.

일반적으로 CSRF 토큰은 세션을 통해 보관하고, 브라우저에서 전송된 CSRF토큰을 검사하는 방식으로 처리한다. 스프릥 시큐리티에서는 CSRF 토큰 생성을 비활성화 하거나
CSRF 토큰을 쿠키를 이용해서 처리하는 등의 설정을 지원한다.

<security:csrf disabled="true"/>


◆로그인 성공과 AuthenticationSuccessHandelr
로그인을 처리하다 보면 로그인 성공 이후에 특정한 동작을 하도록 제어하고 싶은 경우가 있다. 예를 들어 만일 로그인할 때 'admin 계정/ admin 패스워드'로 로그인 했다면
사용자가 어떤 경로로 로그인 페이지로 무조건 '/sample/admin'으로 이동하게 하거나, 별도의 쿠키 등을 생성해서 처리하고 싶은 경우를 생각해볼 수 있다.

이런 경우를 위해서 스프링 시큐리티에서는 AuthenticationSuccessHandler라는 인터페이스를 구현해서 설정할 수 있다.

◆JDBC를 이용하는 간편 인증/권한 처리
비록 security-context.xml 파일에 고정된 몇개의 계정이지만, 로그인 처리가 되었다면 다음 단계는 좀 더 현실적으로 JDBC를 이용하는 방식을 살펴본다. 앞서 언급
했듯이 스프링 시큐리티에서는 사용자를 확인하는 '인증(Authentication)'과 권한 등을 부여하는 '인가 과정(Authorization)'으로 나누어 볼 수 있다.

인증과 권한에 대한 처리는 크게 보면 Authentication Manager를 통해서 이루어지는데 이때 인증이나 권한 정보를 제공하는 존재(Provider)가 필요하고, 다시
이를 위해서 UserDetailsService라는 인터페이스를 구현한 존재를 활용하게 된다.

UserDetailsService는  스프링 시큐리티 API 내에 이미 CachingUserDetailsService, InMemoryUserDetailsManager, JdbcDaoImpl,
JdbcUserDetailManager, LdapUserDetailsService와 같은 구현 클래스들을 제공하고 있다. security-context.xml에 문자열로 고정한 방식은
InMemoryUserDetailsmanager를 이용한 것이다.

기존에 데이터베이스가 존재하는 상황에서 MyBatis나 기타 프레임워크 없이 사용하는 방법을 익혀 본다.

◆JDBC를 이용하기 위한 테이블 설정
JDBC를 이용해서 인증/권한을 체크하는 방식은 크게 1)지정된 형식으로 테이블을 생성해서 사용하는 방식과 2)기존에 작성된 데이터베이스를 이용하는 방식이 있다.

스프링 시큐리티가 JDBC를 이용하는 경우에 사용하는 클래스는 JdbcUserDetailsManager 클래스인데 github 등에 공개된 코드를 보면 아래와 같은 SQL등이
이용되는 것은 확인할 수 있다.
(https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/provisioning/JdbcUserDetailsManager.java)

public static final String DEF_CREATE_USER_SQL = "insert into users (username, password, enabled) values (?,?,?)";
public static final String DEF_DELETE_USER_SQL = "delete from users where username = ?";
public static final String DEF_UPDATE_USER_SQL = "update users set password = ?, enabled = ? where username = ?";
public static final String DEF_INSERT_AUTHORITY_SQL = "insert into authorities (username, authority) values (?,?)";
public static final String DEF_DELETE_USER_AUTHORITIES_SQL = "delete from authorities where username = ?";
public static final String DEF_USER_EXISTS_SQL = "select username from users where username = ?";
public static final String DEF_CHANGE_PASSWORD_SQL = "update users set password = ? where username = ?";

// GroupManager SQL
public static final String DEF_FIND_GROUPS_SQL = "select group_name from groups";
public static final String DEF_FIND_USERS_IN_GROUP_SQL = "select username from group_members gm, groups g "
		+ "where gm.group_id = g.id and g.group_name = ?";
public static final String DEF_INSERT_GROUP_SQL = "insert into groups (group_name) values (?)";
public static final String DEF_FIND_GROUP_ID_SQL = "select id from groups where group_name = ?";
public static final String DEF_INSERT_GROUP_AUTHORITY_SQL = "insert into group_authorities (group_id, authority) values (?,?)";
public static final String DEF_DELETE_GROUP_SQL = "delete from groups where id = ?";
public static final String DEF_DELETE_GROUP_AUTHORITIES_SQL = "delete from group_authorities where group_id = ?";
public static final String DEF_DELETE_GROUP_MEMBERS_SQL = "delete from group_members where group_id = ?";
public static final String DEF_RENAME_GROUP_SQL = "update groups set group_name = ? where group_name = ?";
public static final String DEF_INSERT_GROUP_MEMBER_SQL = "insert into group_members (group_id, username) values (?,?)";
public static final String DEF_DELETE_GROUP_MEMBER_SQL = "delete from group_members where group_id = ? and username = ?";
public static final String DEF_GROUP_AUTHORITIES_QUERY_SQL = "select g.id, g.group_name, ga.authority "
		+ "from groups g, group_authorities ga "
		+ "where g.group_name = ? "
		+ "and g.id = ga.group_id ";
public static final String DEF_DELETE_GROUP_AUTHORITY_SQL = "delete from group_authorities where group_id = ? and authority = ?";


만일 스프링 시큐리티에서 지정된 SQL을 그대로 이용하고 싶다면 지정된 형식으로 테이블을 생성해 주기만 하면 된다.

*스프링 시큐리티의 지정된 테이블을 생성하는 SQL

create table users(
	username varchar2(50) not null primary key,
	password varchar2(50) not null,
	enabled char(1) default '1');
	
create table authorities(
	username varchar2(50) not null,
	authority varchar2(50) not null,
	constraint fk_authorities_users foreign key (username) references users(username));

create unique index ix_auth_username on authorities (username,authority);

insert into users (username, password) values ('user00','pw00');
insert into users (username, password) values ('member00','pw00');
insert into users (username, password) values ('admin00','pw00');

insert into authorities (username, authority) values ('user00', 'ROLE_USER');
insert into authorities (username, authority) values ('member00', 'ROLE_MANAGER');
insert into authorities (username, authority) values ('admin00', 'ROLE_MANAGER');
insert into authorities (username, authority) values ('admin00', 'ROLE_ADMIN');
commit;


◆PasswordEncoder 문제 해결
스프링 시큐리티 5부터는 기본적으로 PasswordEncoder를 지정해야 한다. 앞의 예제는 임시로 '{noop}'접두어를 이용해서 잠시 피해서 진행되었지만,
데이터베이스 등을 이용하는 경우에는 PasswordEncoder라는 것을 이용해야만 한다.

문제는 패스워드 인코딩을 처리하고 나면 사용자의 계정 등을 입력할 때부터 인코딩 작업이 추가되어야 하기 때문에 할 일이 많다는 점이다. 스프링  시큐리티의 
PasswordEncoder는 인터페이스로 설계되어 있고, 이미 여러 종류의 구현 클래스가 존재한다.

4버전까지는 별도의 PasswordEncoder를 이용하고 싶지 않을 때 NoOpPasswordEncoder를 이용해서 처리할 수 있지만, 5버전 부터는 Deprecated
되어서 더 이상 사용할 수 없다. NoOpPasswordEncoder를 사용할 수 없기 때문에 직접 암호화가 없는 PasswordEncoder를 구현해서 사용한다.


◆기존의 테이블을 이용하는 경우
스프링 시큐리티가 기본적으로 이용하는 테이블 구조를 그대로 생성해서 사용하는 방식도 나쁘지 않지만, 기조의 회원 관련 데이터베이스가 구축되어 있다면
이를 사용하는 것은 오히려 더 복잡하게 느껴질 수도 있습니다. JDBC를 이용하고 기존에 테이블이 있다면 약간의 지정된 결과를 반환하는 쿼리를 작성해 주는 
작업으로도 처리가 가능하다. 

<security:jdbc-user-service> 태그에는 아래와 같은 속성들을 지정할 수 있다.

authorities-by-username-query
cache-ref
group-authorities-by-username-query
id
role-prefix
users-by-username-query

속성들 중에서 'users-by-username-query' 속성과 'authorities-by-username-query' 속성에 적당한 쿼리문을 지정해 주면
JDBC를 이용하는 설정을 그대로 사용할 수 있다.

◆인증/권한을 위한 테이블 설계
일반적으로 사용하는 회원 관련 테이블, 권한 테이블을 설계해서 이를 활용해 본다. 이전과 달리 인코딩된 패스워드를 활용해서 좀 더 현실적인 예제를 
작성하도록 한다.

--일반적인 회원 테이블과 권한 테이블
create table tbl_member(
	userid varchar2(50) not null primary key,
	userpw varchar2(100) not null,
	username varchar2(100) not null,
	regdate date default sysdate,
	updatedate date default sysdate,
	enabled char(1) default '1');
	
create table tbl_member_auth(
	userid varchar2(50) not null,
	auth varchar2(50) not null,
	constraint fk_member_auth foreign key(userid) references tbl_member(userid)
);


◆BCryptPasswordEncoder 클래스를 이용한 패스워드 보호
스프링 시큐리티에서 제공되는 BCryptPasswordEncoder 클래스를 이용해서 패스워드를 암호화해서 처리하도록 한다. bcrypt는 태생 자체가
패스워드를 저장하는 용도로 설계된 해시 함수로 특정 문자열로 암호화하고, 체크하는 쪽에서 암호화된 패스워드가 가능한 패트워드이지만 확인하고 다시
원문으로 되돌리지는 못한다.

BcryptPasswordEncoder는 이미 스프링 시큐리티의 API 안에 포함되어 있으므로, 이를 활용해서 security-context.xml에 설정
한다. (기존의 CustomNoOpPasswordEncoder는 사용하지 않으므로 삭제하거나 주석)

bycrypt 방식을 이용하는 PasswordEncoder는 이미 스프링 시큐리티에서 제공하므로 이를 빈으로 추가하고, PasswordEncoder는 
org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder로 지정한다.

◆인코딩된 패스워드를 가지는 사용자 추가
실제 데이터베이스에 기록하는 회원 정보는 BCryptPasswordEncoder를 이용해서 암호화된 상태로 넣어주어야 하므로 테스트 코드를 작성해서
처리한다.

테스트 코드를 실행하기 위해서는 pom.xml에 spring-test를 추가한다.


◆생성된 사용자에게 권한 추가하기
사용자 생성이 완료되었따면 tbl_member_auth 테이블에 사용자의 권하에 대한 정보도 tbl_member_auth 테이블에 추가해야 한다. 
'user00~user79'까지는 'ROLE_USER'권한을 , 'manager80~manager89'까지는 'ROLE_MEMBER'권한을, 'admin90~admin99'
까지는 'ROLE_ADMIN'권한을 부여하는 코드를 작성

◆쿼리를 이용하는 인증
지정된 방식이 아닌 테이블 구조를 이용하는 경우 인증을 하는데 필요한 쿼리(user-by-username-query)와 권한을 확인하는데 필요한 쿼리
(authorities-by-username-query)를 이용해서 처리한다.

*user-by-username-query

select userid, username, userpw, password, enabled
from tbl_member
where userid='admin90'

*authorities-by-username-query
select userid, username,auth authority
from tbl_member_auth
where userid = 'admin90'

위의 쿼리문을 PreparedStatement에서 사용하는 구문으로 바꾸고 <security:jdbc-user-service>태그의 속성으로 지정


◆커스텀 UserDetailsService활용
JDBC를 이용하는 방식으로도 데이터베이스를 처리해서 편리하게 사용할 수 있기는 하지만 약간의 아쉬움은 사용자의 여러 정보들 중에서
제한적인 내용만을 이용하기 때문에 실제 프로젝트에서 사용자의 이름이나 이메일 등의 자세한 정보를 이용할 경우에는 충분하지 못하다는 단점이 있다.

이러한 문제를 해결하기 위해서는 직접 UserDetailsService를 구현하는 방식을 이용하는 것이 좋다. 흔히 커스텀 UserDetailsSerivce
라고 하는데, 이를 이용하면 원하는 객체를 인증과 권한 체크에 활용할 수 있기 때문에 많이 사용한다.

스프링 시큐리티의 UserDetailsService 인터페이스는 단 하나의 메서드만이 존재한다.

loadUserByUsername()이라는 메서드의 반환 타입인 UserDetails 역시 인터페이스로 사용자의 정보와 권한 정보 등을 담는 타입이다.
UserDetails 타입은 getAuthorities(), getPassword(), getUserName()등의 여러 추상 메서드를 가지고 있어서, 개발
전에 이를 직접 구현할 것인지 UserDetails 인터페이스를 구현해둔 스프링 시큐리티의 여러 하위 클래스를 이용할 것인지 판단해야 한다.

가장일반적으로 많이 사용되는 방법은 여러 하위 클래스들 중에서 org.springframework.security.core.userdetails.User클래스를
상속하는 형태이다. 커스텀 UserDetailsService를 이용하는 방식을 이용하기 위해서 MyBatis를 이용하는 MemberMapper와 서비스를 작성하고
이를 스프링 시큐리티와 연결해서 사용하는 방식으로 진행

*MemberMapper
회원에 대한 정보는 MyBatis를 이용해서 처리할 것이므로 MemberMapper를 작성해서 tbl_member와 tbl_member_auth 테이블에 데이터를
추가하고, 조회할 수 있도록 작성한다. Member 객체를 가져오는 경우에는 한 번에 tbl_member와 tbl_member_auth를 조인해서 처리할 수 
있는 방식으로 MyBatis의 ResultMap이라는 기능을 사용한다.

하나의 MemberVO 인스턴스는 내부적으로 여러 개의 AuthVO를 가지는데 이를 흔히 '1+N관계'라고 한다. 즉 하나의 데이터가 여러개의 하위 데이터를
포함하고 있는 것을 의미한다. MyBatis의 ResultMap을 이용하면 하나의 쿼리로  MemberVO와 내부의 AuthVO의 리스트까지 아래와 같이 처리할 수
있다. 

◆CustomUserDetailsService 구성
MyBatis를 이용해서 MemberVO와 같이 회원을 처리하는 부분이 구성되었다면 이를 이용해서 스프링 시큐리티의 UserDetailsService를 구현하는 
클래스를 직접 작성한다. 작성하려는 CustomUserDetailsService는 스프링 시큐리티의 UserDetailsService를 구현하고, MemberMapper
타입의 인스턴스를 주입받아서 실제 기능을 한다.

◆MemberVO를 UsersDetails 타입으로 변환하기
스프링 시큐리티의 UserDetailsService는 loadUserByUserName()라는 하나의 추상 메서트만을 가지고 있으며 리턴 타입은 
org.springframework.security.core.userdetails.UserDetails라는 타입이다. 모든 작업에 문제가 없다면 최종적으로 MemberVO의
인스턴스를 스프링 시큐리티의 UserDetails 타입으로 변환하는 작업을 처리해야 한다.

물론 MemberVO 클래스를 직접 수정해서 UserDetails 인터페이스를 구현하도록 하는 방법도 나쁘지 않다고 생각되지만, 가능하면 기존의 클래스를 
수정하지 않고 확장하는 방식이 더 낫다고 생각되기 때문에 org.zerock.security 패키지에 별도의 domain패키지를 추가해서 CustomUser 클래스 생성

◆스프링 시큐리티를 JSP에서 사용하기
JDBC와 약간의 쿼리를 이용하는 것만으로도 데이터베이스를 이용해서 스프링 시큐리티를 사용할 수 있음에도 불구하고, 굳이 CustomUserDetailsService와
같이 별도의 인증/권한 체크를 하는 가장 큰 이유는 JSP 등에서 단순히 사용자와 아이디(스프링 시큐리티에서는 username) 정도가 아닌 사용자의 이름이나 이메일과
같은 추가적인 정보를 이용하기 위해서이다.

◆JSP에서 로그인한 사용자 정보 보여주기
'/sample/admin'과 같은 정보는 로그인한 사용자만이 접근할 수 있고, 만일 권한이 적당하지 않으면 볼 수 없는 페이지 이므로 로그인 한 사용자가 접근했을 때에는
사용자의 여러 정보를 보여줄 필요가 있다.
스프링 시큐리티와 관련된 정보를 출력하거나 사용하려면 JSP상단에 스프링 시큐리티 관련 태그 라이브러리의 사용을 선언하고, <sec:authentication>태그와
principal이라는 속성을 사용한다.


◆표현식을 이용하는 동적 화면 구성
경우에 따라서는 특정한 페이지에서 로그인한 사용자의 경우에는 특정한 내용을 보여주고, 그렇지 않은 경우에는 다른 내용을 보여주는 경우가 있다.
'/sample/all'이 이런 경우인데 이때 유용한 것이 스프링 시큐리티의 표현식이다.


표현식							설명
hasRole([role])					해당 권한이 있으면 true
hasAuthority([authority])

hasAnyRole([role,role2])
hasAnyAuthority([authority])	여러 권한들 중에서 하나라도 해당하는 권한이 있으면 true

principal 						현재 사용자의 정보를 의미

permitAll						모든 사용자에게 허용

denyAll							모든 사용자에게 거부

isAnonymous()					익명의 사용자의 경우(로그인을 하지 않은 경우도 해당)

isAuthenticated()				인증된 사용자면 true

isFullyAuthenticated()			Remember-me로 인증된 것이 아닌 인증된 사용자인 경우 true

표현식은 거의 대부분 true/false로 리턴하기 때문에 조건문을 사용하는 것처럼 사용된다.
'/sample/all'의 JSP 페이지를 이용해서 사용자의 로그인 상태에 따라 다른 화면을 구성

◆자동로그인(remember-me)
최근의 웹페이지들은 '자동 로그인'이나 '로그인 기억하기'라는 이름으로 한 번 로그인하면 일정 시간 동안 다시 로그인을 하지 않아도 되는 기능을
가지고 있다. 영어로는 'remember-me'라고 표현하는데 이 기능은 거의 대부분 쿠키를 이용해서 구현된다. 

스프링 시큐리티의 경우 'remember-me'기능을 메모리상에서 처리하거나, 데이터베이스를 이용하는 형태로 약간의 설정만으로 구현이 가능하다.
security-context.xml에 <security:remember-me>태그를 이용해서 기능을 구현한다. <security:remember-me>에는
아래와 같이 여러 속성값을 지정할 수 있다. 여러 속성 중에서 주로 사용되는 속성은 다음과 같다.

-key: 쿠키에 사용되는 값을 암호화하기 위한 키(key) 값
-data-source-ref: DataSource를 지정하고 테이블을 이용해서 기존 로그인 정보를 기록(옵션)
-remember-me-cookie: 브라우저에서 보관되는 쿠키의 이름을 지정한다. 기본값은 'remember-me'이다
-remember-me-parameter: 웹 화면에서 로그인할 때 'remember-me'는 대부분 체크박스를 이용해서 처리한다. 이때 체크박스 태그는 name속성을 의미한다.
-token-validity-seconds: 쿠키의 유효시간을 지정한다.

◆데이터베이스를 이용하는 자동 로그인
자동 로그인 기능을 처리하는 방식 중에서 가장 많이 사용되는 방식은 로그인이 되었던 정보를 데이터베이스를 이용해서 기록해 두었다가 사용자의 재방문 시 세션에 정보가 없으면
데이터베이스를 조회해서 사용하는 방식이다. 서버의 메모리상에서만 데이터를 저장하는 방식보다 좋은 점은 데이터베이스에 정보가 공유되기 때문에 좀 더 안정적으로 운영이 가능

스프링 시큐리티에서 'remember-me'기능 역시 JDBC를 이용하는 경우처럼 지정된 이름의 테이블을 생성하면 지정된 SQL문이 실행되면서 이를 처리하는 방식과 직접 구현하는
방식이 있다. 생성된 테이블은 로그인을 유지하는데 필요한 정보를 보관하는 용도일 뿐이므로, 커스터마이징 하기 보다는 지정된 형식의 테이블을 생성한다.

create table persistent_logins(
	username varchar(64) not null,
	series varchar(64) primary key,
	token varchar(64) not null,
	last_used timestamp not null);
	
테이블을 생성하는 스크립트는 특정한 데이터베이스에 맞게 테이블 이름과 칼럼명을 제외한 칼럼의 타입등을 적당히 조정해서 사용한다. 오라클에서는 varchar를 그대로 이용하거나 varchar2
로 변경해서 사용

자동로그인에서 데이터베이스를 이용하는 설정은 별도의 설정없이 data-source-ref만 지정

◆로그아웃 시 쿠키 삭제
자동 로그인 기능을 이용하는 경우에 사용자가 로그아웃을 하면 기존과 달리 자동 로그인에 사용되는 쿠키도 삭제해 주도록 쿠키를 삭제하는 항목을 security-context.xml에 지정


◆Java 설정을 이용하는 경우의 스프링 시큐리티 설정
스프링 시큐리티 역시 다른 설정과 마찬가지로 Java 설정을 이용할 수 있습니다. 다른 예제들과 달리 스프링 시큐리티는 개념이나 용어가 많이 나오기 때문에 XML 쪽을 미리 학습한 후에
Java  설정을 공부하는 것이 좋다.

XML을 이용하는 경우에는 web.xml을 이용해서 스프링 시큐리티 동작에 기본적으로 필요한 필터를 추가하는 작업부터 진행되었지만, web.xml이 없고 WebConfig 클래스를 추가한
상황에서는 1)getServletFilters()를 이용해서 직접 스프링 시큐리티 관련 필터를 추가하거나 2)AbstractSecurityWebApplicationInitializer라는 클래스를 상속하는
클래스를 추가하는 방식을 이용한다

AbstractSecurityWebApplicationInitializer 클래스는 내부적으로 DelegatingFilertProxy를 스프링에 등록하는데 이 작업은 별도의 구현 없이 클래스를 추가하는 것
만으로도 설정이 완료된다.  p690~704 넘어감


◆기존 프로젝트에 스프링 시큐리티 접목하기
순서
-로그인과 회원 가입 페이지의 작성
-기존 화면과 컨트롤러에 시큐리티 관련 내용 추가
-Ajax 부분의 변경

체크해야 하는 학목
-security-context.xml의 추가 /org.zerock.security 및 이하 패키지의 추가 /org.zerock.domain 내에 MemberVO와 AuthVO 클래스 추가
-web.xml에서 security-context.xml 설정과 필터 추가
-MemberMapper 인터페이스와 MemberMapper.xml의 추가
-org.zerock.controller 패키지에 CommonController 추가

이전 예제에서 로그인 성공 후에 CustomLoginSuccessHandler를 이용해서 사용자의 권한에 따라서 이동하도록 했기 때문에 에러 발생. 스프릥 시큐리티는 기본적으로 
로그인 후 처리를 SavedRequestAwareAuthenticationSuccessHandler라는 클래스를 이용한다. 해당 클래스는 사용자가 원래 보려고 했던 페이지의 정보를
유지해서 로그인 후에 다시 원했던 페이지로 이동하는 방식이다.

SavedRequestAwareAuthenticationSuccessHandler를 이용하는 설정은 기존의 XML이나 Java 설정에서 authentication-success-handler-ref
속성이나 successHandler() 메서드를 삭제하고 관련 스프링 빈의 설정도 사용하지 않도록 한다. 예제에서는 게시물의 작성시 로그인 페이지로 이동하고 , 로그인 후에 다시
게시물의 작성 페이지로 이동하는 방식을 적용

◆게시물 작성 시 스프링 시큐리티 처리
일반적인 경우라면 게시물 리스트의 경우 사용자들의 관심을 끌기 위해서 아무 제약 없이 보여주지만, 게시물 작성 시에는 로그인한 사용자에 한해서 처리되는 경우가 많다.
이러한 상항을 고려해 servlet-context.xml에는 스프링 시큐리티 관련 설정을 추가하고, BoardController에 어노테이션을 통해서 제어하도록 한다.

◆CSRF 토큰 설정
스프링 시큐리티를 사용할 때 POST방식의 전송은 반드시 CSRF 토큰을 사용하도록 추가해야만 한다. <form> 태그 내에 CSRF 토큰의 값을 <input type='hidden'>으로 추가

◆스프링 시큐리티 한글 처리
게시물의 등록에서 한 가지 주의할 점은 스프링 시큐리티의 적용 이후 한글이 꺠지는 문제가 발생할 수도 있다는 점이다. 한글 처리는 web.xml을 이용해서 스프링의 CharacterEncodingFilter
를 이용해서 처리하지만, 시큐리티를 필터로 적용할 때에는 필터의 순서를 주의해서 설정해야만 한다.
인코딩 설정을 먼저 적용하고, 스프링 시큐리티 적용

 ◆게시물 조회와 로그인 처리
<sec:authentication>태그를 매번 이용하는 것은 불편하기 때문에 로그인과 관련된 정보인 principal은 아에 JSP 내에서 pinfo라는 이름의 변수로 사용하도록 한다.
<sec:authorize>는 인증받은 사용자만이 영향을 받기 위해서 지정하고, 내부에서는 username과 게시물의 writer가 일치하는지를 확인해서 'Modify'버튼을 추가한다.
브라우저에는 자신이 작성한 게시물만이 'Modify'버튼이 보이게 된다.

◆조회화면에서 댓글 추가 버튼
로그인한 사용자만이 조회화면에서 댓글을 추가할 수 있으므로, <sec:authorize>를 이용해서 댓글 버튼의 활성화/비활성화도 처리하도록 한다.

◆게시물의 수정/삭제
게시물의 수저오가 삭제는 브라우저에서는 로그인한 사용자만이 접근할 수 있지만, 사용자가 URL을 조작해서도 접근이 가능하기 때문에 화면과 POST방식으로 처리되는 부분에서 CSRF토큰과 스프링시큐리티를 적용

게시물의 수정과 삭제에서 신경쓰이는 부분은 게시물의 수정과 삭제는 현재 로그인한 사용자와 게시물의 작성자가 동일한 경우에만 할 수 있다는 것이다. 이 처리를 과거에는 인터셉터로 처리했지만,
@PreAuthorize의 경우에는 표현식으로 처리할 수 있다.

◆BoardController에서의 제어
BoardController에서는 메서드를 실행하기 전에 로그인한 사용자와 현재 파라미터로 전달되는 작성자가 일치하는지 체크한다. @PreAuthorize의 경우 문자열로
표현식을 지정할 수 있는데 이때 컨트롤러에 전달되는 파라미터를 같이 사용할 수 있으므로 유용하다.

삭제의 경우 기존에는 파라미터로 게시물의 번호 bno만을 받았지만, 작성자를 의미하는 writer를 같이 추가해서 @PreAuthorize로 검사하도록 한다.

◆Ajax와 스프링 시큐리티 처리
<form> 태그를 이용하는 방식 외에 많이 사용하는 Ajax를 이용하는 경우에는 약간의 추가적인 설정이 필요하다. 예제는 파일 업로드와 댓글 부분이 Ajax를 이용하므로
로그인한 사용자만이 해당 기능드릉ㄹ 사용할 수 있도록 수정해 본다.

스프링 시큐리티가 적용되면 POST, PUT, PATCH, DELETE와 같은 방식으로 데이터를 전송하는 경우에는 반드시 추가적으로 'X-CSRF-TOKEN'와 같은
헤더를 추가해서 CSRF 토큰값을 전달하도록 수정해야만 한다. Ajax는 JavaScript를 이용하기 때문에 브라우저에서는 CSRF 토큰과 관련된 값을 변수로 선언하고, 전송
시 포함시켜주는 방식으로 수정한다.

◆댓글 기능에서의 Ajax
댓글의 경우 모든 동작들이 Ajax를 통해서 이루어지기 때문에 화면에서도 수정되어야 하는 부분이 있고, 서버 쪽에서도 변경될 부분이 꽤있다. 우선 서버 쪽에서는 ReplyController가
댓글에 대한 보안 원칙을 다음과 같이 설계 할 수 있다.

-댓글의 등록: 로그인한 사용자만이 댓글을 추가할 수 있도록 한다.
-댓글의 수정과 삭제: 로그인한 사용자와 댓글 작성자의 아이디를 비교해서 같은 경우에만 댓글을 수정/삭제 할 수 있다.

브라우저 쪽에서는 기존과 달라지는 부분은 다음과 같다.
-댓글의 등록 : CSRF 토큰을 같이 전송하도록 수정해야 한다.
-댓글의 수정/삭제: 기존의 댓글 삭제에는 댓글 번호만으로 처리했는데, 서버 쪽에서 사용할 것으로 댓글 작성자를 같이 전송하도록 수정

